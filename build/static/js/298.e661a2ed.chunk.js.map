{"version":3,"file":"static/js/298.e661a2ed.chunk.js","mappings":"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","sources":["../node_modules/pixi.js/src/app/ResizePlugin.ts","../node_modules/pixi.js/src/app/TickerPlugin.ts","../node_modules/pixi.js/src/app/init.ts","../node_modules/pixi.js/src/filters/FilterPipe.ts","../node_modules/pixi.js/src/scene/container/bounds/getFastGlobalBounds.ts","../node_modules/pixi.js/src/filters/FilterSystem.ts","../node_modules/pixi.js/src/scene/container/bounds/getRenderableBounds.ts","../node_modules/pixi.js/src/filters/init.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.ts","../node_modules/pixi.js/src/scene/graphics/shared/GraphicsPipe.ts","../node_modules/pixi.js/src/scene/graphics/init.ts","../node_modules/pixi.js/src/scene/mesh/shared/MeshPipe.ts","../node_modules/pixi.js/src/scene/mesh/init.ts","../node_modules/pixi.js/src/scene/mesh/shared/BatchableMesh.ts","../node_modules/pixi.js/src/scene/mesh/shared/MeshGeometry.ts","../node_modules/pixi.js/src/scene/mesh-plane/PlaneGeometry.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceGeometry.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceSpritePipe.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/init.ts","../node_modules/pixi.js/src/scene/sprite-tiling/shader/tilingBit.ts","../node_modules/pixi.js/src/scene/sprite-tiling/shader/TilingSpriteShader.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/QuadGeometry.ts","../node_modules/pixi.js/src/scene/sprite-tiling/TilingSpritePipe.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/setUvs.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/applyMatrix.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/setPositions.ts","../node_modules/pixi.js/src/scene/sprite-tiling/init.ts","../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/localUniformMSDFBit.ts","../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/mSDFBit.ts","../node_modules/pixi.js/src/scene/text/sdfShader/SdfShader.ts","../node_modules/pixi.js/src/scene/text-bitmap/BitmapTextPipe.ts","../node_modules/pixi.js/src/scene/text-bitmap/init.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextPipe.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextRenderData.ts","../node_modules/pixi.js/src/scene/text-html/utils/textStyleToCSS.ts","../node_modules/pixi.js/src/scene/text-html/HtmlTextStyle.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadFontCSS.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadFontAsBase64.ts","../node_modules/pixi.js/src/scene/text-html/utils/getFontCss.ts","../node_modules/pixi.js/src/scene/text-html/utils/measureHtmlText.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextSystem.ts","../node_modules/pixi.js/src/scene/text-html/utils/extractFontFamilies.ts","../node_modules/pixi.js/src/scene/text-html/utils/getSVGUrl.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadSVGImage.ts","../node_modules/pixi.js/src/utils/browser/isSafari.ts","../node_modules/pixi.js/src/scene/text-html/utils/getTemporaryCanvasFromImage.ts","../node_modules/pixi.js/src/scene/text-html/init.ts","../node_modules/pixi.js/src/scene/text/canvas/CanvasTextPipe.ts","../node_modules/pixi.js/src/utils/canvas/getCanvasBoundingBox.ts","../node_modules/pixi.js/src/scene/text/canvas/CanvasTextSystem.ts","../node_modules/pixi.js/src/scene/text/init.ts","../node_modules/pixi.js/src/scene/text/utils/getPo2TextureFromSource.ts"],"sourcesContent":["import { ExtensionType } from '../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { Renderer } from '../rendering/renderers/types';\n\ntype ResizeableRenderer = Pick<Renderer, 'resize'>;\n\n/**\n * Application options for the {@link app.ResizePlugin}.\n * @memberof app\n * @property {Window|HTMLElement} [resizeTo=window] - Element to automatically resize the renderer to.\n */\nexport interface ResizePluginOptions\n{\n    /**\n     * Element to automatically resize the renderer to.\n     * @memberof app.ApplicationOptions\n     */\n    resizeTo?: Window | HTMLElement;\n}\n\n/**\n * Middleware for Application's resize functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#resizeTo}\n * * {@link app.Application#resize}\n * * {@link app.Application#queueResize}\n * * {@link app.Application#cancelResize}\n * @example\n * import { extensions, ResizePlugin } from 'pixi.js';\n *\n * extensions.add(ResizePlugin);\n * @memberof app\n */\nexport class ResizePlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static resizeTo: Window | HTMLElement;\n    public static resize: () => void;\n    public static renderer: ResizeableRenderer;\n    public static queueResize: () => void;\n    public static render: () => void;\n    private static _resizeId: number;\n    private static _resizeTo: Window | HTMLElement;\n    private static _cancelResize: () => void;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options: ResizePluginOptions): void\n    {\n        Object.defineProperty(this, 'resizeTo',\n            /**\n             * The HTML element or window to automatically resize the\n             * renderer's view element to match width and height.\n             * @member {Window|HTMLElement}\n             * @name resizeTo\n             * @memberof app.Application#\n             */\n            {\n                set(dom: Window | HTMLElement)\n                {\n                    globalThis.removeEventListener('resize', this.queueResize);\n                    this._resizeTo = dom;\n                    if (dom)\n                    {\n                        globalThis.addEventListener('resize', this.queueResize);\n                        this.resize();\n                    }\n                },\n                get()\n                {\n                    return this._resizeTo;\n                },\n            });\n\n        /**\n         * Resize is throttled, so it's safe to call this multiple times per frame and it'll\n         * only be called once.\n         * @memberof app.Application#\n         * @method queueResize\n         * @private\n         */\n        this.queueResize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            this._cancelResize();\n\n            // // Throttle resize events per raf\n            this._resizeId = requestAnimationFrame(() => this.resize());\n        };\n\n        /**\n         * Cancel the resize queue.\n         * @memberof app.Application#\n         * @method cancelResize\n         * @private\n         */\n        this._cancelResize = (): void =>\n        {\n            if (this._resizeId)\n            {\n                cancelAnimationFrame(this._resizeId);\n                this._resizeId = null;\n            }\n        };\n\n        /**\n         * Execute an immediate resize on the renderer, this is not\n         * throttled and can be expensive to call many times in a row.\n         * Will resize only if `resizeTo` property is set.\n         * @memberof app.Application#\n         * @method resize\n         */\n        this.resize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            // clear queue resize\n            this._cancelResize();\n\n            let width: number;\n            let height: number;\n\n            // Resize to the window\n            if (this._resizeTo === globalThis.window)\n            {\n                width = globalThis.innerWidth;\n                height = globalThis.innerHeight;\n            }\n            // Resize to other HTML entities\n            else\n            {\n                const { clientWidth, clientHeight } = this._resizeTo as HTMLElement;\n\n                width = clientWidth;\n                height = clientHeight;\n            }\n\n            this.renderer.resize(width, height);\n            this.render();\n        };\n\n        // On resize\n        this._resizeId = null;\n        this._resizeTo = null;\n        this.resizeTo = options.resizeTo || null;\n    }\n\n    /**\n     * Clean up the ticker, scoped to application\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        globalThis.removeEventListener('resize', this.queueResize);\n        this._cancelResize();\n        this._cancelResize = null;\n        this.queueResize = null;\n        this.resizeTo = null;\n        this.resize = null;\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Application options for the {@link app.TickerPluginOptions}.\n * @memberof app\n * @property {boolean} [autoStart=true] - Automatically starts the rendering after the construction.\n * **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n * `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n * @property {boolean} [sharedTicker=false] - Set`true` to use `Ticker.shared`, `false` to create new ticker.\n * If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n * The system ticker will always run before both the shared ticker and the app ticker.\n */\nexport interface TickerPluginOptions\n{\n    /**\n     * Automatically starts the rendering after the construction.\n     *  **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n     *  `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n     * @memberof app.ApplicationOptions\n     * @default true\n     */\n    autoStart?: boolean;\n    /**\n     * Set`true` to use `Ticker.shared`, `false` to create new ticker.\n     *  If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n     *  The system ticker will always run before both the shared ticker and the app ticker.\n     * @memberof app.ApplicationOptions\n     * @default false\n     */\n    sharedTicker?: boolean;\n}\n\n/**\n * Middleware for Application's {@link ticker.Ticker} functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#start}\n * * {@link app.Application#stop}\n * * {@link app.Application#ticker}\n * @example\n * import { extensions, TickerPlugin } from 'pixi.js';\n *\n * extensions.add(TickerPlugin);\n * @memberof app\n */\nexport class TickerPlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static start: () => void;\n    public static stop: () => void;\n    private static _ticker: Ticker;\n    public static ticker: Ticker;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options?: PixiMixins.ApplicationOptions): void\n    {\n        // Set default\n        options = Object.assign({\n            autoStart: true,\n            sharedTicker: false,\n        }, options);\n\n        // Create ticker setter\n        Object.defineProperty(this, 'ticker',\n            {\n                set(ticker)\n                {\n                    if (this._ticker)\n                    {\n                        this._ticker.remove(this.render, this);\n                    }\n                    this._ticker = ticker;\n                    if (ticker)\n                    {\n                        ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n                    }\n                },\n                get()\n                {\n                    return this._ticker;\n                },\n            });\n\n        /**\n         * Convenience method for stopping the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.stop = (): void =>\n        {\n            this._ticker.stop();\n        };\n\n        /**\n         * Convenience method for starting the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.start = (): void =>\n        {\n            this._ticker.start();\n        };\n\n        /**\n         * Internal reference to the ticker.\n         * @type {Ticker}\n         * @name _ticker\n         * @memberof app.Application#\n         * @private\n         */\n        this._ticker = null;\n\n        /**\n         * Ticker for doing render updates.\n         * @type {ticker.Ticker}\n         * @name ticker\n         * @memberof app.Application#\n         * @default Ticker.shared\n         */\n        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n\n        // Start the rendering\n        if (options.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Clean up the ticker, scoped to application.\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        if (this._ticker)\n        {\n            const oldTicker = this._ticker;\n\n            this.ticker = null;\n            oldTicker.destroy();\n        }\n    }\n}\n","import { extensions } from '../extensions/Extensions';\nimport { ResizePlugin } from './ResizePlugin';\nimport { TickerPlugin } from './TickerPlugin';\n\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { Effect } from '../scene/container/Effect';\nimport type { FilterInstruction } from './FilterSystem';\n\n// eslint-disable-next-line max-len\nexport class FilterPipe implements InstructionPipe<FilterInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'filter',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(filterEffect: Effect, container: Container, instructionSet: InstructionSet): void\n    {\n        const renderPipes = this._renderer.renderPipes;\n\n        renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            canBundle: false,\n            action: 'pushFilter',\n            container,\n            filterEffect,\n        } as FilterInstruction);\n    }\n\n    public pop(_filterEffect: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: FilterInstruction)\n    {\n        if (instruction.action === 'pushFilter')\n        {\n            this._renderer.filter.push(instruction);\n        }\n        else if (instruction.action === 'popFilter')\n        {\n            this._renderer.filter.pop();\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { boundsPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\n// TODO could we cache local bounds on the render groups?\n\nconst tempMatrix = new Matrix();\n\n/**\n * Does exactly the same as getGlobalBounds, but does instead makes use of transforming AABBs\n * of the various children within the scene graph. This is much faster, but less accurate.\n *\n * the result will never be smaller - only ever slightly larger (in most cases, it will be the same).\n * @param target - The target container to get the bounds from\n * @param bounds - The output bounds object.\n * @returns The bounds.\n */\nexport function getFastGlobalBounds(target: Container, bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    _getGlobalBoundsRecursive(target, bounds);\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    if (!target.renderGroup)\n    {\n        bounds.applyMatrix(target.parentRenderGroup.worldTransform);\n    }\n    else\n    {\n        bounds.applyMatrix(target.renderGroup.localTransform);\n    }\n\n    return bounds;\n}\n\nexport function _getGlobalBoundsRecursive(\n    target: Container,\n    bounds: Bounds,\n)\n{\n    if (target.localDisplayStatus !== 0b111 || !target.measurable)\n    {\n        return;\n    }\n\n    const manageEffects = !!target.effects.length;\n\n    let localBounds = bounds;\n\n    if (target.renderGroup || manageEffects)\n    {\n        localBounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, target.worldTransform);\n    }\n    else\n    {\n        if (target.renderPipeId)\n        {\n            const viewBounds = (target as Renderable).bounds;\n\n            localBounds.addFrame(\n                viewBounds.minX,\n                viewBounds.minY,\n                viewBounds.maxX,\n                viewBounds.maxY,\n                target.groupTransform\n            );\n        }\n\n        const children = target.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            _getGlobalBoundsRecursive(children[i], localBounds);\n        }\n    }\n\n    if (manageEffects)\n    {\n        let advanced = false;\n\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            if (target.effects[i].addBounds)\n            {\n                if (!advanced)\n                {\n                    advanced = true;\n                    localBounds.applyMatrix(target.parentRenderGroup.worldTransform);\n                }\n\n                target.effects[i].addBounds(localBounds, true);\n            }\n        }\n\n        if (advanced)\n        {\n            localBounds.applyMatrix(target.parentRenderGroup.worldTransform.copyTo(tempMatrix).invert());\n            bounds.addBounds(localBounds, target.relativeGroupTransform);\n        }\n\n        bounds.addBounds(localBounds);\n        boundsPool.return(localBounds);\n    }\n    else if (target.renderGroup)\n    {\n        bounds.addBounds(localBounds, target.relativeGroupTransform);\n        boundsPool.return(localBounds);\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { Point } from '../maths/point/Point';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getFastGlobalBounds } from '../scene/container/bounds/getFastGlobalBounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\ntype FilterAction = 'pushFilter' | 'popFilter';\n\n//\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            location: 0,\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: FilterAction,\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\nexport interface FilterData\n{\n    skip: boolean;\n    enabledLength?: number;\n    inputTexture: Texture\n    bounds: Bounds,\n    blendRequired: boolean,\n    container: Container,\n    filterEffect: FilterEffect,\n    previousRenderSurface: RenderSurface,\n    backTexture?: Texture,\n}\n\n/**\n * System that manages the filter pipeline\n * @memberof rendering\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: Renderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        if (!this._filterStack[this._filterStackIndex])\n        {\n            this._filterStack[this._filterStackIndex] = this._getFilterData();\n        }\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        this._filterStackIndex++;\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds: Bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            getFastGlobalBounds(instruction.container, bounds);\n        }\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        const colorTextureSource = renderer.renderTarget.rootRenderTarget.colorTexture.source;\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = colorTextureSource._resolution;\n\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for any filter, it should be true\n        let antialias = colorTextureSource.antialias;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            resolution = Math.min(resolution, filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias !== 'inherit')\n            {\n                if (filter.antialias === 'on')\n                {\n                    antialias = true;\n                }\n                else\n                {\n                    antialias = false;\n                }\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = filter.enabled || enabled;\n            blendRequired = blendRequired || filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const viewPort = renderer.renderTarget.rootViewPort;\n\n        // here we constrain the bounds to the viewport we will render too\n        // this should not take into account the x, y offset of the viewport - as this is\n        // handled by the viewport on the gpu.\n        // need to factor in resolutions also..\n        bounds.scale(resolution)\n            .fitBounds(0, viewPort.width, 0, viewPort.height)\n            .scale(1 / resolution)\n            .pad(padding)\n            .ceil();\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set all the filter data\n        filterData.skip = false;\n\n        filterData.bounds = bounds;\n        filterData.blendRequired = blendRequired;\n        filterData.container = instruction.container;\n        filterData.filterEffect = instruction.filterEffect;\n\n        filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            resolution,\n            antialias,\n        );\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n        // set the global uniforms to take into account the bounds offset required\n\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        this._filterStackIndex--;\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        this._activeFilterData = filterData;\n\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        let backTexture = Texture.EMPTY;\n\n        renderer.renderTarget.finishRenderPass();\n\n        if (filterData.blendRequired)\n        {\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n\n            backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n        }\n\n        filterData.backTexture = backTexture;\n\n        const filters = filterData.filterEffect.filters;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        // eslint-disable-next-line max-len\n\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(backTexture.source, 3);\n\n        renderer.globalUniforms.pop();\n\n        if (filters.length === 1)\n        {\n            // render a single filter...\n            // this.applyFilter(filters[0], inputTexture, filterData.previousRenderSurface, false);\n            filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n\n            // return the texture to the pool so we can reuse the next frame\n            TexturePool.returnTexture(inputTexture);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            // get another texture that we will render the next filter too\n            let flop = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            let i = 0;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                const filter = filters[i];\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n\n            // return those textures for later!\n            TexturePool.returnTexture(flip);\n            TexturePool.returnTexture(flop);\n        }\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(backTexture);\n        }\n    }\n\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        const bounds = filterData.bounds;\n\n        const offset = Point.shared;\n        const previousRenderSurface = filterData.previousRenderSurface;\n\n        const isFinalTarget = previousRenderSurface === output;\n\n        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n\n        // to find the previous resolution we need to account for the skipped filters\n        // the following will find the last non skipped filter...\n        let currentIndex = this._filterStackIndex - 1;\n\n        while (currentIndex > 0 && this._filterStack[currentIndex].skip)\n        {\n            --currentIndex;\n        }\n\n        if (currentIndex > 0)\n        {\n            resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n        }\n\n        const filterUniforms = this._filterGlobalUniforms;\n        const uniforms = filterUniforms.uniforms;\n\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (isFinalTarget)\n        {\n            let lastIndex = this._filterStackIndex;\n\n            // get previous bounds.. we must take into account skipped filters also..\n            while (lastIndex > 0)\n            {\n                lastIndex--;\n                const filterData = this._filterStack[this._filterStackIndex - 1];\n\n                if (!filterData.skip)\n                {\n                    offset.x = filterData.bounds.minX;\n                    offset.y = filterData.bounds.minY;\n\n                    break;\n                }\n            }\n\n            outputFrame[0] = bounds.minX - offset.x;\n            outputFrame[1] = bounds.minY - offset.y;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[0] = offset.x * resolution;\n        globalFrame[1] = offset.y * resolution;\n\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n\n        // set the output texture - this is where we are going to render to\n\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n        filterUniforms.update();\n\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(filterUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(filterUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    private _getFilterData(): FilterData\n    {\n        return {\n            skip: false,\n            inputTexture: null,\n            bounds: new Bounds(),\n            container: null,\n            filterEffect: null,\n            blendRequired: false,\n            previousRenderSurface: null,\n        };\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.frame.width,\n            1.0 / sprite.texture.frame.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy?: () => void;\n}\n","import type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Bounds } from './Bounds';\n\nexport function getGlobalRenderableBounds(renderables: Renderable[], bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    // instead of copying the matrix each time we are assigning it in bounds\n    // this is a performance hack :D\n    // so we need to restore the matrix after we are done\n\n    const tempMatrix = bounds.matrix;\n\n    for (let i = 0; i < renderables.length; i++)\n    {\n        const renderable = renderables[i];\n\n        if (renderable.globalDisplayStatus < 0b111)\n        {\n            continue;\n        }\n\n        bounds.matrix = renderable.worldTransform;\n        renderable.addBounds(bounds);\n    }\n\n    bounds.matrix = tempMatrix;\n\n    return bounds;\n}\n","import { extensions } from '../extensions/Extensions';\nimport { FilterPipe } from './FilterPipe';\nimport { FilterSystem } from './FilterSystem';\n\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n","import { UniformGroup } from '../../shared/shader/UniformGroup';\n\nconst batchSamplersUniformGroupHash: Record<number, UniformGroup> = {};\n\n/**\n * Automatically generates a uniform group that holds the texture samplers for a shader.\n * This is used mainly by the shaders that batch textures!\n * @param maxTextures - the number of textures that this uniform group will contain.\n * @returns a uniform group that holds the texture samplers.\n */\nexport function getBatchSamplersUniformGroup(maxTextures: number)\n{\n    let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];\n\n    if (batchSamplersUniformGroup) return batchSamplersUniformGroup;\n\n    const sampleValues = new Int32Array(maxTextures);\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        sampleValues[i] = i;\n    }\n\n    batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new UniformGroup({\n        uTextures: { value: sampleValues, type: `i32`, size: maxTextures }\n    }, { isStatic: true });\n\n    return batchSamplersUniformGroup;\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../gpu/colorToUniform';\nimport { BatchableGraphics } from './BatchableGraphics';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Graphics } from './Graphics';\nimport type { GpuGraphicsContext, GraphicsContextSystem } from './GraphicsContextSystem';\n\nexport interface GraphicsAdaptor\n{\n    shader: Shader;\n    init(): void;\n    execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void;\n    destroy(): void;\n}\nexport interface GraphicsSystem\n{\n    graphicsContext: GraphicsContextSystem;\n    renderPipes: {\n        batch: BatchPipe\n    }\n    _roundPixels: 0 | 1;\n}\n\nexport class GraphicsPipe implements RenderPipe<Graphics>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public renderer: GraphicsSystem;\n    public state: State = State.for2d();\n\n    // batchable graphics list, used to render batches\n    private _graphicsBatchesHash: Record<number, BatchableGraphics[]> = Object.create(null);\n    private _adaptor: GraphicsAdaptor;\n\n    constructor(renderer: GraphicsSystem, adaptor: GraphicsAdaptor)\n    {\n        this.renderer = renderer;\n\n        this._adaptor = adaptor;\n        this._adaptor.init();\n    }\n\n    public validateRenderable(graphics: Graphics): boolean\n    {\n        // assume context is dirty..\n\n        const context = graphics.context;\n\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable)\n        {\n            // TODO what if they are the same size??\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // need to get batches here.. as we need to know if we can batch or not..\n        // this also overrides the current batches..\n\n        if (graphics._didGraphicsUpdate)\n        {\n            graphics._didGraphicsUpdate = false;\n\n            this._rebuild(graphics);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._addToBatcher(graphics, instructionSet);\n        }\n        else\n        {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n\n    public updateRenderable(graphics: Graphics)\n    {\n        const batches = this._graphicsBatchesHash[graphics.uid];\n\n        if (batches)\n        {\n            for (let i = 0; i < batches.length; i++)\n            {\n                const batch = batches[i];\n\n                batch.batcher.updateElement(batch);\n            }\n        }\n    }\n\n    public destroyRenderable(graphics: Graphics)\n    {\n        if (this._graphicsBatchesHash[graphics.uid])\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n    }\n\n    public execute(graphics: Graphics)\n    {\n        if (!graphics.isRenderable) return;\n\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext;\n\n        // early out if there is no actual visual stuff...\n        if (!contextSystem.getGpuContext(context).batches.length)\n        { return; }\n\n        const shader = context.customShader || this._adaptor.shader;\n\n        this.state.blendMode = graphics.groupBlendMode;\n\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n\n        color32BitToUniform(\n            graphics.groupColorAlpha,\n            localUniforms.uColor,\n            0,\n        );\n\n        this._adaptor.execute(this, graphics);\n    }\n\n    private _rebuild(graphics: Graphics)\n    {\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // TODO POOL the old batches!\n\n        if (wasBatched)\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._initBatchesForRenderable(graphics);\n        }\n\n        graphics.batched = gpuContext.isBatchable;\n    }\n\n    private _addToBatcher(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const batchPipe = this.renderer.renderPipes.batch;\n\n        const batches = this._getBatchesForRenderable(graphics);\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n\n    private _getBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);\n    }\n\n    private _initBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        const context = graphics.context;\n\n        const gpuContext: GpuGraphicsContext = this.renderer.graphicsContext.getGpuContext(context);\n\n        const roundPixels = (this.renderer._roundPixels | graphics._roundPixels) as 0 | 1;\n\n        const batches = gpuContext.batches.map((batch) =>\n        {\n            // TODO pool this!!\n            const batchClone = BigPool.get(BatchableGraphics);\n\n            batch.copyTo(batchClone);\n\n            batchClone.renderable = graphics;\n\n            batchClone.roundPixels = roundPixels;\n\n            return batchClone;\n        });\n\n        if (this._graphicsBatchesHash[graphics.uid] === undefined)\n        {\n            // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n            graphics.on('destroyed', () =>\n            {\n                this.destroyRenderable(graphics);\n            });\n        }\n\n        this._graphicsBatchesHash[graphics.uid] = batches;\n\n        return batches;\n    }\n\n    private _removeBatchForRenderable(graphicsUid: number)\n    {\n        this._graphicsBatchesHash[graphicsUid].forEach((batch) =>\n        {\n            BigPool.return(batch as PoolItem);\n        });\n\n        this._graphicsBatchesHash[graphicsUid] = null;\n    }\n\n    public destroy()\n    {\n        this.renderer = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n\n        for (const i in this._graphicsBatchesHash)\n        {\n            this._removeBatchForRenderable(i as unknown as number);\n        }\n\n        this._graphicsBatchesHash = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem';\nimport { GraphicsPipe } from './shared/GraphicsPipe';\n\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from './BatchableMesh';\n\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type {\n    InstructionPipe,\n    RenderPipe\n} from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Mesh } from './Mesh';\n\n// TODO Record mode is a P2, will get back to this as it's not a priority\n// const recordMode = true;\n\ninterface MeshData\n{\n    batched: boolean;\n    indexSize: number;\n    vertexSize: number;\n}\n\nexport interface MeshAdaptor\n{\n    init(): void;\n    execute(meshPipe: MeshPipe, mesh: Mesh): void;\n    destroy(): void;\n}\n\nexport interface MeshInstruction extends Instruction\n{\n    renderPipeId: 'mesh';\n    mesh: Mesh;\n}\n\n// eslint-disable-next-line max-len\nexport class MeshPipe implements RenderPipe<Mesh>, InstructionPipe<MeshInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'mesh',\n    } as const;\n\n    public localUniforms = new UniformGroup({\n        uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n        uRound: { value: 0, type: 'f32' },\n    });\n\n    public localUniformsBindGroup = new BindGroup({\n        0: this.localUniforms,\n    });\n\n    public renderer: Renderer;\n\n    private _meshDataHash: Record<number, MeshData> = Object.create(null);\n    private _gpuBatchableMeshHash: Record<number, BatchableMesh> = Object.create(null);\n    private _adaptor: MeshAdaptor;\n\n    constructor(renderer: Renderer, adaptor: MeshAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init();\n    }\n\n    public validateRenderable(mesh: Mesh): boolean\n    {\n        const meshData = this._getMeshData(mesh);\n\n        const wasBatched = meshData.batched;\n\n        const isBatched = mesh.batched;\n\n        meshData.batched = isBatched;\n\n        if (wasBatched !== isBatched)\n        {\n            return true;\n        }\n        else if (isBatched)\n        {\n            const geometry = mesh._geometry;\n\n            // no need to break the batch if it's the same size\n            if (geometry.indices.length !== meshData.indexSize\n                    || geometry.positions.length !== meshData.vertexSize)\n            {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n\n                return true;\n            }\n\n            const batchableMesh = this._getBatchableMesh(mesh);\n\n            const texture = mesh.texture;\n\n            if (batchableMesh.texture._source !== texture._source)\n            {\n                if (batchableMesh.texture._source !== texture._source)\n                {\n                    return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public addRenderable(mesh: Mesh, instructionSet: InstructionSet)\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        const { batched } = this._getMeshData(mesh);\n\n        if (batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            batcher.addToBatch(gpuBatchableMesh);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            instructionSet.add({\n                renderPipeId: 'mesh',\n                mesh\n            } as MeshInstruction);\n        }\n    }\n\n    public updateRenderable(mesh: Mesh)\n    {\n        if (mesh.batched)\n        {\n            const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n\n    public destroyRenderable(mesh: Mesh)\n    {\n        this._meshDataHash[mesh.uid] = null;\n\n        const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n        if (gpuMesh)\n        {\n            BigPool.return(gpuMesh as PoolItem);\n            this._gpuBatchableMeshHash[mesh.uid] = null;\n        }\n    }\n\n    public execute({ mesh }: MeshInstruction)\n    {\n        if (!mesh.isRenderable) return;\n\n        mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);\n\n        const localUniforms = this.localUniforms;\n\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n\n        color32BitToUniform(\n            mesh.groupColorAlpha,\n            localUniforms.uniforms.uColor,\n            0\n        );\n\n        this._adaptor.execute(this, mesh);\n    }\n\n    private _getMeshData(mesh: Mesh): MeshData\n    {\n        return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n    }\n\n    private _initMeshData(mesh: Mesh): MeshData\n    {\n        this._meshDataHash[mesh.uid] = {\n            batched: mesh.batched,\n            indexSize: mesh._geometry.indices?.length,\n            vertexSize: mesh._geometry.positions?.length,\n        };\n\n        mesh.on('destroyed', () =>\n        {\n            this.destroyRenderable(mesh);\n        });\n\n        return this._meshDataHash[mesh.uid];\n    }\n\n    private _getBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n    }\n\n    private _initBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        // TODO - make this batchable graphics??\n        const gpuMesh: BatchableMesh = BigPool.get(BatchableMesh);\n\n        gpuMesh.mesh = mesh;\n        gpuMesh.texture = mesh._texture;\n        gpuMesh.roundPixels = (this.renderer._roundPixels | mesh._roundPixels) as 0 | 1;\n\n        this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n\n        gpuMesh.mesh = mesh;\n\n        return gpuMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuBatchableMeshHash)\n        {\n            if (this._gpuBatchableMeshHash[i])\n            {\n                BigPool.return(this._gpuBatchableMeshHash[i] as PoolItem);\n            }\n        }\n\n        this._gpuBatchableMeshHash = null;\n        this._meshDataHash = null;\n\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n\n        this.renderer = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { MeshPipe } from './shared/MeshPipe';\n\nextensions.add(MeshPipe);\n","import type { Batch, BatchableObject, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Container } from '../../container/Container';\nimport type { MeshGeometry } from './MeshGeometry';\n\n/**\n * A batchable mesh object.\n * @ignore\n */\nexport class BatchableMesh implements BatchableObject\n{\n    public indexStart: number;\n    public textureId: number;\n    public texture: Texture;\n    public location: number;\n    public batcher: Batcher = null;\n    public batch: Batch = null;\n    public mesh: Container;\n    public geometry: MeshGeometry;\n\n    public roundPixels: 0 | 1 = 0;\n\n    private _transformedUvs: Float32Array;\n    private _uvUpdateId: number = -1;\n    private _textureMatrixUpdateId: number = -1;\n\n    get blendMode() { return this.mesh.groupBlendMode; }\n\n    public reset()\n    {\n        this.mesh = null;\n        this.texture = null;\n        this.batcher = null;\n        this.batch = null;\n    }\n\n    public packIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        const indices = this.geometry.indices;\n\n        for (let i = 0; i < indices.length; i++)\n        {\n            indexBuffer[index++] = indices[i] + indicesOffset;\n        }\n    }\n\n    public packAttributes(\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const mesh = this.mesh;\n\n        const geometry = this.geometry;\n        const wt = mesh.groupTransform;\n\n        const textureIdAndRound = (textureId << 16) | (this.roundPixels & 0xFFFF);\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        // const trim = texture.trim;\n        const positions = geometry.positions;\n        const uvBuffer = geometry.getBuffer('aUV');\n\n        const uvs = uvBuffer.data;\n\n        let transformedUvs = uvs;\n        const textureMatrix = this.texture.textureMatrix;\n\n        if (!textureMatrix.isSimple)\n        {\n            transformedUvs = this._transformedUvs;\n\n            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID)\n            {\n                if (!transformedUvs || transformedUvs.length < uvs.length)\n                {\n                    transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n                }\n\n                this._textureMatrixUpdateId = textureMatrix._updateID;\n                this._uvUpdateId = uvBuffer._updateID;\n\n                textureMatrix.multiplyUvs(uvs as Float32Array, transformedUvs);\n            }\n        }\n\n        const abgr = mesh.groupColorAlpha;\n\n        for (let i = 0; i < positions.length; i += 2)\n        {\n            const x = positions[i];\n            const y = positions[i + 1];\n\n            float32View[index] = (a * x) + (c * y) + tx;\n            float32View[index + 1] = (b * x) + (d * y) + ty;\n\n            // TODO implement texture matrix?\n            float32View[index + 2] = transformedUvs[i];\n            float32View[index + 3] = transformedUvs[i + 1];\n\n            uint32View[index + 4] = abgr;\n            uint32View[index + 5] = textureIdAndRound;\n\n            index += 6;\n        }\n    }\n\n    get vertexSize()\n    {\n        return this.geometry.positions.length / 2;\n    }\n\n    get indexSize()\n    {\n        return this.geometry.indices.length;\n    }\n}\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { BatchMode } from '../../graphics/shared/GraphicsContext';\n\n/**\n * Options for the mesh geometry.\n * @memberof scene\n */\nexport interface MeshGeometryOptions\n{\n    /** The positions of the mesh. */\n    positions?: Float32Array;\n    /** The UVs of the mesh. */\n    uvs?: Float32Array;\n    /** The indices of the mesh. */\n    indices?: Uint32Array;\n    /** The topology of the mesh. */\n    topology?: Topology;\n    /** Whether to shrink the buffers to fit the data. */\n    shrinkBuffersToFit?: boolean;\n}\n\n/**\n * A geometry used to batch multiple meshes with the same texture.\n * @memberof scene\n */\nexport class MeshGeometry extends Geometry\n{\n    public static defaultOptions: MeshGeometryOptions = {\n        topology: 'triangle-list',\n        shrinkBuffersToFit: false,\n    };\n\n    public batchMode: BatchMode = 'auto';\n\n    /**\n     * @param {scene.MeshGeometryOptions} options - The options of the mesh geometry.\n     */\n    constructor(options: MeshGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(positions: Float32Array, uvs: Float32Array, indices: Uint32Array);\n    constructor(...args: [MeshGeometryOptions] | [Float32Array, Float32Array, Uint32Array])\n    {\n        let options = args[0] ?? {};\n\n        if (options instanceof Float32Array)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new MeshGeometry({ positions, uvs, indices }) instead');\n            // #endif\n\n            options = {\n                positions: options,\n                uvs: args[1],\n                indices: args[2],\n            };\n        }\n\n        options = { ...MeshGeometry.defaultOptions, ...options };\n\n        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n        const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n\n        const shrinkToFit = options.shrinkBuffersToFit;\n\n        const positionBuffer = new Buffer({\n            data: positions,\n            label: 'attribute-mesh-positions',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const uvBuffer = new Buffer({\n            data: uvs,\n            label: 'attribute-mesh-uvs',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const indexBuffer = new Buffer({\n            data: indices,\n            label: 'index-mesh-buffer',\n            shrinkToFit,\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n        });\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: positionBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: uvBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n            },\n            indexBuffer,\n            topology: options.topology,\n        });\n    }\n\n    /** The positions of the mesh. */\n    get positions(): Float32Array\n    {\n        return this.attributes.aPosition.buffer.data as Float32Array;\n    }\n\n    set positions(value: Float32Array)\n    {\n        this.attributes.aPosition.buffer.data = value;\n    }\n\n    /** The UVs of the mesh. */\n    get uvs(): Float32Array\n    {\n        return this.attributes.aUV.buffer.data as Float32Array;\n    }\n\n    set uvs(value: Float32Array)\n    {\n        this.attributes.aUV.buffer.data = value;\n    }\n\n    /** The indices of the mesh. */\n    get indices(): Uint32Array\n    {\n        return this.indexBuffer.data as Uint32Array;\n    }\n\n    set indices(value: Uint32Array)\n    {\n        this.indexBuffer.data = value;\n    }\n}\n","import { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\n\nimport type { MeshGeometryOptions } from '../mesh/shared/MeshGeometry';\n\n/**\n * Constructor options used for `PlaneGeometry` instances.\n * ```js\n * const planeGeometry = new PlaneGeometry({\n *    width: 100,\n *    height: 100,\n *    verticesX: 10,\n *    verticesY: 10,\n * });\n * ```\n * @see {@link scene.PlaneGeometry}\n * @memberof scene\n */\nexport interface PlaneGeometryOptions\n{\n    /** Width of plane */\n    width?: number;\n    /** Height of plane */\n    height?: number;\n    /** Number of vertices on x-axis */\n    verticesX?: number;\n    /** Number of vertices on y-axis */\n    verticesY?: number;\n}\n\n/**\n * The PlaneGeometry allows you to draw a 2d plane\n * @memberof scene\n */\nexport class PlaneGeometry extends MeshGeometry\n{\n    public static defaultOptions: PlaneGeometryOptions & MeshGeometryOptions = {\n        width: 100,\n        height: 100,\n        verticesX: 10,\n        verticesY: 10,\n    };\n\n    /** The number of vertices on x-axis */\n    public verticesX: number;\n    /** The number of vertices on y-axis */\n    public verticesY: number;\n    /** The width of plane */\n    public width: number;\n    /** The height of plane */\n    public height: number;\n\n    /**\n     * @param {PlaneGeometryOptions} options - Options to be applied to plane geometry\n     */\n    constructor(options: PlaneGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(width?: number, height?: number, verticesX?: number, verticesY?: number);\n    constructor(...args: [PlaneGeometryOptions?] | [number?, number?, number?, number?])\n    {\n        super({});\n\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead');\n            // #endif\n\n            options = {\n                width: options,\n                height: args[1],\n                verticesX: args[2],\n                verticesY: args[3],\n            };\n        }\n\n        this.build(options);\n    }\n\n    /**\n     * Refreshes plane coordinates\n     * @param options - Options to be applied to plane geometry\n     */\n    public build(options: PlaneGeometryOptions): void\n    {\n        options = { ...PlaneGeometry.defaultOptions, ...options };\n\n        this.verticesX = this.verticesX ?? options.verticesX;\n        this.verticesY = this.verticesY ?? options.verticesY;\n\n        this.width = this.width ?? options.width;\n        this.height = this.height ?? options.height;\n\n        const total = this.verticesX * this.verticesY;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n\n        const verticesX = this.verticesX - 1;\n        const verticesY = this.verticesY - 1;\n\n        const sizeX = (this.width) / verticesX;\n        const sizeY = (this.height) / verticesY;\n\n        for (let i = 0; i < total; i++)\n        {\n            const x = (i % this.verticesX);\n            const y = ((i / this.verticesX) | 0);\n\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / verticesX, y / verticesY);\n        }\n\n        const totalSub = verticesX * verticesY;\n\n        for (let i = 0; i < totalSub; i++)\n        {\n            const xpos = i % verticesX;\n            const ypos = (i / verticesX) | 0;\n\n            const value = (ypos * this.verticesX) + xpos;\n            const value2 = (ypos * this.verticesX) + xpos + 1;\n            const value3 = ((ypos + 1) * this.verticesX) + xpos;\n            const value4 = ((ypos + 1) * this.verticesX) + xpos + 1;\n\n            indices.push(value, value2, value3,\n                value2, value4, value3);\n        }\n\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint32Array(indices);\n\n        // ensure that the changes are uploaded\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n}\n","import { PlaneGeometry } from '../mesh-plane/PlaneGeometry';\n\n/**\n * Options for the NineSliceGeometry.\n * @memberof scene\n */\nexport interface NineSliceGeometryOptions\n{\n\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    width?: number\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    height?: number\n    /** The original width of the texture */\n    originalWidth?: number\n    /** The original height of the texture */\n    originalHeight?: number\n    /** The width of the left column. */\n    leftWidth?: number\n    /** The height of the top row. */\n    topHeight?: number\n    /** The width of the right column. */\n    rightWidth?: number\n    /** The height of the bottom row. */\n    bottomHeight?: number\n}\n\n/**\n * The NineSliceGeometry class allows you to create a NineSlicePlane object.\n * @memberof scene\n */\nexport class NineSliceGeometry extends PlaneGeometry\n{\n    /** The default options for the NineSliceGeometry. */\n    public static defaultOptions: NineSliceGeometryOptions = {\n        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        width: 100,\n        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        height: 100,\n        /** The width of the left column. */\n        leftWidth: 10,\n        /** The height of the top row. */\n        topHeight: 10,\n        /** The width of the right column. */\n        rightWidth: 10,\n        /** The height of the bottom row. */\n        bottomHeight: 10,\n\n        /** The original width of the texture */\n        originalWidth: 100,\n        /** The original height of the texture */\n        originalHeight: 100,\n    };\n\n    public _leftWidth: number;\n    public _rightWidth: number;\n    public _topHeight: number;\n    public _bottomHeight: number;\n\n    private _originalWidth: number;\n    private _originalHeight: number;\n\n    constructor(options: NineSliceGeometryOptions = {})\n    {\n        options = { ...NineSliceGeometry.defaultOptions, ...options };\n\n        super({\n            width: options.width,\n            height: options.height,\n            verticesX: 4,\n            verticesY: 4,\n        });\n\n        this.update(options);\n    }\n\n    /**\n     * Updates the NineSliceGeometry with the options.\n     * @param options - The options of the NineSliceGeometry.\n     */\n    public update(options: NineSliceGeometryOptions)\n    {\n        this.width = options.width ?? this.width;\n        this.height = options.height ?? this.height;\n        this._originalWidth = options.originalWidth ?? this._originalWidth;\n        this._originalHeight = options.originalHeight ?? this._originalHeight;\n        this._leftWidth = options.leftWidth ?? this._leftWidth;\n        this._rightWidth = options.rightWidth ?? this._rightWidth;\n        this._topHeight = options.topHeight ?? this._topHeight;\n        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n\n        this.updateUvs();\n        this.updatePositions();\n    }\n\n    /** Updates the positions of the vertices. */\n    public updatePositions()\n    {\n        const positions = this.positions;\n\n        const w = this._leftWidth + this._rightWidth;\n        const scaleW = this.width > w ? 1.0 : this.width / w;\n\n        const h = this._topHeight + this._bottomHeight;\n        const scaleH = this.height > h ? 1.0 : this.height / h;\n\n        const scale = Math.min(scaleW, scaleH);\n\n        positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;\n        positions[17] = positions[19] = positions[21] = positions[23] = this.height - (this._bottomHeight * scale);\n        positions[25] = positions[27] = positions[29] = positions[31] = this.height;\n\n        positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;\n        positions[4] = positions[12] = positions[20] = positions[28] = this.width - (this._rightWidth * scale);\n        positions[6] = positions[14] = positions[22] = positions[30] = this.width;\n\n        this.getBuffer('aPosition').update();\n    }\n\n    /** Updates the UVs of the vertices. */\n    public updateUvs()\n    {\n        const uvs = this.uvs;\n\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n\n        const _uvw = 1.0 / this._originalWidth;\n        const _uvh = 1.0 / this._originalHeight;\n\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - (_uvw * this._rightWidth);\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - (_uvh * this._bottomHeight);\n\n        this.getBuffer('aUV').update();\n    }\n}\n\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { NineSliceGeometry } from './NineSliceGeometry';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { NineSliceSprite } from './NineSliceSprite';\n\nexport class NineSliceSpritePipe implements RenderPipe<NineSliceSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'nineSliceSprite',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private readonly _gpuSpriteHash: Record<number, BatchableMesh> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderable(sprite: NineSliceSprite, _instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite._didSpriteUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite);\n    }\n\n    public updateRenderable(sprite: NineSliceSprite)\n    {\n        const gpuSprite = this._gpuSpriteHash[sprite.uid];\n\n        if (sprite._didSpriteUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite.batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: NineSliceSprite): boolean\n    {\n        const texture = sprite._texture;\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (gpuSprite.texture._source !== texture._source)\n        {\n            return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);\n        }\n\n        return false;\n    }\n\n    public destroyRenderable(sprite: NineSliceSprite)\n    {\n        const batchableSprite = this._gpuSpriteHash[sprite.uid];\n\n        // this will call reset!\n        BigPool.return(batchableSprite as PoolItem);\n\n        this._gpuSpriteHash[sprite.uid] = null;\n    }\n\n    private _updateBatchableSprite(sprite: NineSliceSprite, batchableSprite: BatchableMesh)\n    {\n        sprite._didSpriteUpdate = false;\n        (batchableSprite.geometry as NineSliceGeometry)\n            .update(sprite);\n\n        // = sprite.bounds;\n        batchableSprite.texture = sprite._texture;\n    }\n\n    private _getGpuSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        const batchableMesh = new BatchableMesh();\n\n        batchableMesh.geometry = new NineSliceGeometry();\n\n        batchableMesh.mesh = sprite;\n\n        batchableMesh.texture = sprite._texture;\n        batchableMesh.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        this._gpuSpriteHash[sprite.uid] = batchableMesh;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        sprite.on('destroyed', () =>\n        {\n            this.destroyRenderable(sprite);\n        });\n\n        return batchableMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuSpriteHash)\n        {\n            const batchableMesh = this._gpuSpriteHash[i];\n\n            batchableMesh.geometry.destroy();\n        }\n\n        (this._gpuSpriteHash as null) = null;\n        (this._renderer as null) = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe';\n\nextensions.add(NineSliceSpritePipe);\n","export const tilingBit = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            } \n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    }\n\n};\n\nexport const tilingBitGl = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n        \n        `,\n        main: /* glsl */`\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `,\n        main: /* glsl */`\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n        \n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n    \n        `\n    }\n\n};\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { tilingBit, tilingBitGl } from './tilingBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\nexport class TilingSpriteShader extends Shader\n{\n    constructor()\n    {\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBit,\n                tilingBit,\n                roundPixelsBit,\n            ],\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBitGl,\n                tilingBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        const tilingUniforms = new UniformGroup({\n            uMapCoord: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: 'vec4<f32>' },\n            uClampOffset: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n            uTextureTransform: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: 'vec4<f32>' },\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: new UniformGroup({\n                    uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n                    uRound: { value: 0, type: 'f32' },\n                }),\n                tilingUniforms,\n                uTexture: Texture.EMPTY.source,\n                uSampler: Texture.EMPTY.source.style,\n            }\n        });\n    }\n\n    public updateUniforms(\n        width: number, height: number,\n        matrix: Matrix,\n        anchorX: number, anchorY: number,\n        texture: Texture\n    ): void\n    {\n        const tilingUniforms = this.resources.tilingUniforms;\n\n        const textureWidth = texture.width;\n        const textureHeight = texture.height;\n        const textureMatrix = texture.textureMatrix;\n\n        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n\n        uTextureTransform.set(\n            matrix.a * textureWidth / width,\n            matrix.b * textureWidth / height,\n            matrix.c * textureHeight / width,\n            matrix.d * textureHeight / height,\n            matrix.tx / width,\n            matrix.ty / height);\n\n        uTextureTransform.invert();\n\n        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n        tilingUniforms.uniforms.uSizeAnchor[0] = width;\n        tilingUniforms.uniforms.uSizeAnchor[1] = height;\n        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n\n        if (texture)\n        {\n            this.resources.uTexture = texture.source;\n            this.resources.uSampler = texture.source.style;\n        }\n    }\n}\n","import { MeshGeometry } from '../../mesh/shared/MeshGeometry';\n\nexport class QuadGeometry extends MeshGeometry\n{\n    constructor()\n    {\n        super({\n            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n        });\n    }\n}\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { getAdjustedBlendModeBlend } from '../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../rendering/renderers/shared/state/State';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader';\nimport { QuadGeometry } from './utils/QuadGeometry';\nimport { setPositions } from './utils/setPositions';\nimport { setUvs } from './utils/setUvs';\n\nimport type { WebGLRenderer } from '../../rendering/renderers/gl/WebGLRenderer';\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { TilingSprite } from './TilingSprite';\n\ninterface RenderableData\n{\n    canBatch: boolean;\n    renderable: TilingSprite\n    batchableMesh?: BatchableMesh;\n    geometry?: MeshGeometry;\n    shader?: TilingSpriteShader;\n}\n\nconst sharedQuad = new QuadGeometry();\n\nexport class TilingSpritePipe implements RenderPipe<TilingSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'tilingSprite',\n    } as const;\n\n    private _renderer: Renderer;\n    private readonly _state: State = State.default2d;\n    private readonly _tilingSpriteDataHash: Record<number, RenderableData> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(renderable: TilingSprite): boolean\n    {\n        const tilingSpriteData = this._getTilingSpriteData(renderable);\n\n        const couldBatch = tilingSpriteData.canBatch;\n\n        this._updateCanBatch(renderable);\n\n        const canBatch = tilingSpriteData.canBatch;\n\n        if (canBatch && canBatch === couldBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            // we are batching.. check a texture change!\n            if (batchableMesh && batchableMesh.texture._source !== renderable.texture._source)\n            {\n                return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, renderable.texture);\n            }\n        }\n\n        return (couldBatch !== canBatch);\n\n        // // TODO - only update if required?\n        // // only texture\n        // // only uvs\n        // // only positions?\n    }\n\n    public addRenderable(tilingSprite: TilingSprite, instructionSet: InstructionSet)\n    {\n        const batcher = this._renderer.renderPipes.batch;\n\n        // init\n        this._updateCanBatch(tilingSprite);\n\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry, canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            tilingSpriteData.batchableMesh ||= new BatchableMesh();\n\n            const batchableMesh = tilingSpriteData.batchableMesh;\n\n            if (tilingSprite._didTilingSpriteUpdate)\n            {\n                tilingSprite._didTilingSpriteUpdate = false;\n\n                this._updateBatchableMesh(tilingSprite);\n\n                batchableMesh.geometry = geometry;\n                batchableMesh.mesh = tilingSprite;\n                batchableMesh.texture = tilingSprite._texture;\n            }\n\n            batchableMesh.roundPixels = (this._renderer._roundPixels | tilingSprite._roundPixels) as 0 | 1;\n\n            batcher.addToBatch(batchableMesh);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            tilingSpriteData.shader ||= new TilingSpriteShader();\n\n            this.updateRenderable(tilingSprite);\n\n            instructionSet.add(tilingSprite);\n        }\n    }\n\n    public execute(tilingSprite: TilingSprite)\n    {\n        const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];\n\n        shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n\n        // deal with local uniforms...\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n\n        color32BitToUniform(\n            tilingSprite.groupColorAlpha,\n            localUniforms.uColor,\n            0\n        );\n\n        this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);\n\n        this._renderer.encoder.draw({\n            geometry: sharedQuad,\n            shader,\n            state: this._state,\n        });\n    }\n\n    public updateRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            if (tilingSprite._didTilingSpriteUpdate) this._updateBatchableMesh(tilingSprite);\n\n            batchableMesh.batcher.updateElement(batchableMesh);\n        }\n        else if (tilingSprite._didTilingSpriteUpdate)\n        {\n            const { shader } = tilingSpriteData;\n            // now update uniforms...\n\n            shader.updateUniforms(\n                tilingSprite.width,\n                tilingSprite.height,\n                tilingSprite._tileTransform.matrix,\n                tilingSprite.anchor.x,\n                tilingSprite.anchor.y,\n                tilingSprite.texture,\n            );\n        }\n\n        tilingSprite._didTilingSpriteUpdate = false;\n    }\n\n    public destroyRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        tilingSpriteData.batchableMesh = null;\n\n        tilingSpriteData.shader?.destroy();\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = null;\n    }\n\n    private _getTilingSpriteData(renderable: TilingSprite): RenderableData\n    {\n        return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);\n    }\n\n    private _initTilingSpriteData(tilingSprite: TilingSprite): RenderableData\n    {\n        const geometry = new MeshGeometry({\n            indices: sharedQuad.indices,\n            positions: sharedQuad.positions.slice(),\n            uvs: sharedQuad.uvs.slice(),\n        });\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = {\n            canBatch: true,\n            renderable: tilingSprite,\n            geometry,\n        };\n\n        tilingSprite.on('destroyed', () =>\n        {\n            this.destroyRenderable(tilingSprite);\n        });\n\n        return this._tilingSpriteDataHash[tilingSprite.uid];\n    }\n\n    private _updateBatchableMesh(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry } = renderableData;\n\n        const style = tilingSprite.texture.source.style;\n\n        if (style.addressMode !== 'repeat')\n        {\n            style.addressMode = 'repeat';\n            style.update();\n        }\n\n        setUvs(tilingSprite, geometry.uvs);\n        setPositions(tilingSprite, geometry.positions);\n    }\n\n    public destroy()\n    {\n        for (const i in this._tilingSpriteDataHash)\n        {\n            this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);\n        }\n\n        (this._tilingSpriteDataHash as null) = null;\n        this._renderer = null;\n    }\n\n    private _updateCanBatch(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const texture = tilingSprite.texture;\n\n        let _nonPowOf2wrapping = true;\n\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            _nonPowOf2wrapping = (this._renderer as WebGLRenderer).context.supports.nonPowOf2wrapping;\n        }\n\n        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n\n        return renderableData.canBatch;\n    }\n}\n\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { applyMatrix } from './applyMatrix';\n\nimport type { TilingSprite } from '../TilingSprite';\n\nexport function setUvs(tilingSprite: TilingSprite, uvs: Float32Array)\n{\n    const texture = tilingSprite.texture;\n\n    const width = texture.frame.width;\n    const height = texture.frame.height;\n\n    let anchorX = 0;\n    let anchorY = 0;\n\n    if (tilingSprite._applyAnchorToTexture)\n    {\n        anchorX = tilingSprite.anchor.x;\n        anchorY = tilingSprite.anchor.y;\n    }\n\n    uvs[0] = uvs[6] = -anchorX;\n    uvs[2] = uvs[4] = 1 - anchorX;\n    uvs[1] = uvs[3] = -anchorY;\n    uvs[5] = uvs[7] = 1 - anchorY;\n\n    const textureMatrix = Matrix.shared;\n\n    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n\n    textureMatrix.tx /= tilingSprite.width;\n    textureMatrix.ty /= tilingSprite.height;\n\n    textureMatrix.invert();\n\n    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n\n    applyMatrix(uvs, 2, 0, textureMatrix);\n}\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { TypedArray } from '../../../rendering/renderers/shared/buffer/Buffer';\n\nexport function applyMatrix(array: TypedArray, stride: number, offset: number, matrix: Matrix)\n{\n    let index = 0;\n    const size = array.length / (stride || 2);\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    offset *= stride;\n\n    while (index < size)\n    {\n        const x = array[offset];\n        const y = array[offset + 1];\n\n        array[offset] = (a * x) + (c * y) + tx;\n        array[offset + 1] = (b * x) + (d * y) + ty;\n\n        offset += stride;\n\n        index++;\n    }\n}\n","import type { TilingSprite } from '../TilingSprite';\n\nexport function setPositions(tilingSprite: TilingSprite, positions: Float32Array)\n{\n    const anchorX = tilingSprite.anchor.x;\n    const anchorY = tilingSprite.anchor.y;\n\n    positions[0] = -anchorX * tilingSprite.width;\n    positions[1] = -anchorY * tilingSprite.height;\n    positions[2] = (1 - anchorX) * tilingSprite.width;\n    positions[3] = -anchorY * tilingSprite.height;\n    positions[4] = (1 - anchorX) * tilingSprite.width;\n    positions[5] = (1 - anchorY) * tilingSprite.height;\n    positions[6] = -anchorX * tilingSprite.width;\n    positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { TilingSpritePipe } from './TilingSpritePipe';\n\nextensions.add(TilingSpritePipe);\n","// TODO eventually we should not use this bit, but instead use the localUniformBit\n// have the MSDF bit be merged in with the localUniformBit\n\nexport const localUniformMSDFBit = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */` \n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        `\n\n    }\n};\n\nexport const localUniformMSDFBitGl = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform float uDistance;\n         `,\n        main: /* glsl */` \n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        `\n\n    }\n};\n","export const mSDFBit = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* wgsl */`\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n             \n            }\n        `,\n    }\n\n};\n\nexport const mSDFBitGl = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* glsl */`\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);  \n              \n                return coverage;\n            }\n        `,\n    }\n\n};\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { getMaxTexturesPerBatch } from '../../../rendering/batcher/gl/utils/maxRecommendedTextures';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport {\n    generateTextureBatchBit,\n    generateTextureBatchBitGl\n} from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\nexport class SdfShader extends Shader\n{\n    constructor()\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uDistance: { value: 4, type: 'f32' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        const maxTextures = getMaxTexturesPerBatch();\n\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(maxTextures),\n                localUniformMSDFBit,\n                mSDFBit,\n                roundPixelsBit\n            ]\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                localUniformMSDFBitGl,\n                mSDFBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n}\n","import { Cache } from '../../assets/cache/Cache';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { Graphics } from '../graphics/shared/Graphics';\nimport { SdfShader } from '../text/sdfShader/SdfShader';\nimport { BitmapFontManager } from './BitmapFontManager';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../rendering/renderers/shared/Renderable';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { BitmapText } from './BitmapText';\n\nexport class BitmapTextPipe implements RenderPipe<BitmapText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'bitmapText',\n    } as const;\n\n    private _renderer: Renderer;\n    private _gpuBitmapText: Record<number, Graphics> = {};\n    // private _sdfShader: SdfShader;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(bitmapText: BitmapText): boolean\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n\n        // TODO - need to shift all the verts in the graphicsData to the new anchor\n\n        // update the anchor...\n    }\n\n    public addRenderable(bitmapText: BitmapText, instructionSet: InstructionSet)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    public destroyRenderable(bitmapText: BitmapText)\n    {\n        this._destroyRenderableByUid(bitmapText.uid);\n    }\n\n    private _destroyRenderableByUid(renderableUid: number)\n    {\n        const context = this._gpuBitmapText[renderableUid].context;\n\n        if (context.customShader)\n        {\n            BigPool.return(context.customShader as PoolItem);\n\n            context.customShader = null;\n        }\n\n        BigPool.return(this._gpuBitmapText[renderableUid] as PoolItem);\n        this._gpuBitmapText[renderableUid] = null;\n    }\n\n    public updateRenderable(bitmapText: BitmapText)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    private _updateContext(bitmapText: BitmapText, proxyGraphics: Graphics)\n    {\n        const { context } = proxyGraphics;\n\n        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n\n        context.clear();\n\n        if (bitmapFont.distanceField.type !== 'none')\n        {\n            if (!context.customShader)\n            {\n                context.customShader = BigPool.get(SdfShader);\n            }\n        }\n\n        const chars = Array.from(bitmapText.text);\n        const style = bitmapText._style;\n\n        let currentY = bitmapFont.baseLineOffset;\n\n        // measure our text...\n        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont);\n\n        let index = 0;\n\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n\n        context\n            .translate(\n                (-bitmapText._anchor._x * bitmapTextLayout.width) - padding,\n                (-bitmapText._anchor._y * (bitmapTextLayout.height + bitmapTextLayout.offsetY)) - padding)\n            .scale(scale, scale);\n\n        const tint = bitmapFont.applyFillAsTint ? style._fill.color : 0xFFFFFF;\n\n        for (let i = 0; i < bitmapTextLayout.lines.length; i++)\n        {\n            const line = bitmapTextLayout.lines[i];\n\n            for (let j = 0; j < line.charPositions.length; j++)\n            {\n                const char = chars[index++];\n\n                const charData = bitmapFont.chars[char];\n\n                if (charData?.texture)\n                {\n                    context.texture(\n                        charData.texture,\n                        tint ? tint : 'black',\n                        Math.round(line.charPositions[j] + charData.xOffset),\n                        Math.round(currentY + charData.yOffset),\n                    );\n                }\n            }\n\n            currentY += bitmapFont.lineHeight;\n        }\n    }\n\n    private _getGpuBitmapText(bitmapText: BitmapText)\n    {\n        return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);\n    }\n\n    public initGpuText(bitmapText: BitmapText)\n    {\n        // TODO we could keep a bunch of contexts around and reuse one that hav the same style!\n        const proxyRenderable = BigPool.get(Graphics);\n\n        this._gpuBitmapText[bitmapText.uid] = proxyRenderable;\n\n        this._updateContext(bitmapText, proxyRenderable);\n\n        bitmapText.on('destroyed', () =>\n        {\n            this.destroyRenderable(bitmapText);\n        });\n\n        return this._gpuBitmapText[bitmapText.uid];\n    }\n\n    private _updateDistanceField(bitmapText: BitmapText)\n    {\n        const context = this._getGpuBitmapText(bitmapText).context;\n\n        const fontFamily = bitmapText._style.fontFamily as string;\n        const dynamicFont = Cache.get(`${fontFamily as string}-bitmap`);\n\n        // Inject the shader code with the correct value\n        const { a, b, c, d } = bitmapText.groupTransform;\n\n        const dx = Math.sqrt((a * a) + (b * b));\n        const dy = Math.sqrt((c * c) + (d * d));\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);\n\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n\n    public destroy()\n    {\n        for (const uid in this._gpuBitmapText)\n        {\n            this._destroyRenderableByUid(uid as unknown as number);\n        }\n\n        this._gpuBitmapText = null;\n\n        this._renderer = null;\n    }\n}\n\nfunction syncWithProxy(container: Renderable, proxy: Renderable)\n{\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { BitmapTextPipe } from './BitmapTextPipe';\n\nextensions.add(BitmapTextPipe);\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\n\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { HTMLText } from './HTMLText';\nimport type { HTMLTextStyle } from './HtmlTextStyle';\n\nexport class HTMLTextPipe implements RenderPipe<HTMLText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        textureNeedsUploading: boolean;\n        generatingTexture: boolean;\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(htmlText: HTMLText): boolean\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const newKey = htmlText._getKey();\n\n        if (gpuText.textureNeedsUploading)\n        {\n            gpuText.textureNeedsUploading = false;\n\n            return true;\n        }\n\n        if (gpuText.currentKey !== newKey)\n        {\n            // TODO - could look into optimising this a tad!\n            // if its a single texture, then we could just swap it?\n            // same for CanvasText..\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(htmlText: HTMLText)\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n    }\n\n    public updateRenderable(htmlText: HTMLText)\n    {\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        batchableSprite.batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(htmlText: HTMLText)\n    {\n        this._destroyRenderableById(htmlText.uid);\n    }\n\n    private _destroyRenderableById(htmlTextUid: number)\n    {\n        const gpuText = this._gpuText[htmlTextUid];\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[htmlTextUid] = null;\n    }\n\n    private _updateText(htmlText: HTMLText)\n    {\n        const newKey = htmlText._getKey();\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(htmlText).catch((e) =>\n            {\n                console.error(e);\n            });\n        }\n\n        htmlText._didTextUpdate = false;\n\n        const padding = htmlText._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n\n    private async _updateGpuText(htmlText: HTMLText)\n    {\n        htmlText._didTextUpdate = false;\n\n        const gpuText = this._getGpuText(htmlText);\n\n        if (gpuText.generatingTexture) return;\n\n        const newKey = htmlText._getKey();\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        gpuText.generatingTexture = true;\n\n        gpuText.currentKey = newKey;\n\n        const resolution = htmlText.resolution ?? this._renderer.resolution;\n\n        const texture = await this._renderer.htmlText.getManagedTexture(\n            htmlText.text,\n            resolution,\n            htmlText._style as HTMLTextStyle,\n            htmlText._getKey()\n        );\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        batchableSprite.texture = gpuText.texture = texture;\n\n        gpuText.generatingTexture = false;\n\n        gpuText.textureNeedsUploading = true;\n        htmlText.onViewUpdate();\n\n        const padding = htmlText._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n\n    private _getGpuText(htmlText: HTMLText)\n    {\n        return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);\n    }\n\n    public initGpuText(htmlText: HTMLText)\n    {\n        const gpuTextData: HTMLTextPipe['_gpuText'][number] = {\n            texture: Texture.EMPTY,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n            textureNeedsUploading: false,\n            generatingTexture: false,\n        };\n\n        const batchableSprite = gpuTextData.batchableSprite;\n\n        batchableSprite.renderable = htmlText;\n        batchableSprite.texture = Texture.EMPTY;\n        batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableSprite.roundPixels = (this._renderer._roundPixels | htmlText._roundPixels) as 0 | 1;\n\n        this._gpuText[htmlText.uid] = gpuTextData;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        htmlText.on('destroyed', () =>\n        {\n            this.destroyRenderable(htmlText);\n        });\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n\n","import type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\n\nexport const nssvg = 'http://www.w3.org/2000/svg';\nexport const nsxhtml = 'http://www.w3.org/1999/xhtml';\n\nexport class HTMLTextRenderData\n{\n    public svgRoot = document.createElementNS(nssvg, 'svg');\n    public foreignObject = document.createElementNS(nssvg, 'foreignObject');\n    public domElement = document.createElementNS(nsxhtml, 'div');\n    public styleElement = document.createElementNS(nsxhtml, 'style');\n    public image = new Image();\n    public canvasAndContext?: CanvasAndContext;\n\n    constructor()\n    {\n        const { foreignObject, svgRoot, styleElement, domElement } = this;\n        // Arbitrary max size\n\n        foreignObject.setAttribute('width', '10000');\n        foreignObject.setAttribute('height', '10000');\n        foreignObject.style.overflow = 'hidden';\n\n        svgRoot.appendChild(foreignObject);\n\n        foreignObject.appendChild(styleElement);\n        foreignObject.appendChild(domElement);\n    }\n}\n","import { Color } from '../../../color/Color';\n\nimport type { ConvertedStrokeStyle } from '../../graphics/shared/FillTypes';\nimport type { TextStyle } from '../../text/TextStyle';\nimport type { HTMLTextStyle, HTMLTextStyleOptions } from '../HtmlTextStyle';\n\n/**\n * Internally converts all of the style properties into CSS equivalents.\n * @param style\n * @returns The CSS style string, for setting `style` property of root HTMLElement.\n */\nexport function textStyleToCSS(style: HTMLTextStyle): string\n{\n    const stroke = style._stroke;\n    const fill = style._fill;\n\n    const cssStyleString = [\n        `color: ${Color.shared.setValue(fill.color).toHex()}`,\n        `font-size: ${(style.fontSize as number)}px`,\n        `font-family: ${style.fontFamily}`,\n        `font-weight: ${style.fontWeight}`,\n        `font-style: ${style.fontStyle}`,\n        `font-variant: ${style.fontVariant}`,\n        `letter-spacing: ${style.letterSpacing}px`,\n        `text-align: ${style.align}`,\n        `padding: ${style.padding}px`,\n        `white-space: ${(style.whiteSpace === 'pre' && style.wordWrap) ? 'pre-wrap' : style.whiteSpace}`,\n        ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],\n        ...style.wordWrap ? [\n            `word-wrap: ${style.breakWords ? 'break-all' : 'break-word'}`,\n            `max-width: ${style.wordWrapWidth}px`\n        ] : [],\n        ...stroke ? [strokeToCSS(stroke)] : [],\n        ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],\n        ...style.cssOverrides,\n    ].join(';');\n\n    const cssStyles = [`div { ${cssStyleString} }`];\n\n    tagStyleToCSS(style.tagStyles, cssStyles);\n\n    return cssStyles.join(' ');\n}\n\nfunction dropShadowToCSS(dropShadowStyle: TextStyle['dropShadow']): string\n{\n    const color = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n    const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n    const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n\n    const position = `${x}px ${y}px`;\n\n    if (dropShadowStyle.blur > 0)\n    {\n        return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n    }\n\n    return `text-shadow: ${position} ${color}`;\n}\n\nfunction strokeToCSS(stroke: ConvertedStrokeStyle): string\n{\n    return [\n        `-webkit-text-stroke-width: ${stroke.width}px`,\n        `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        `text-stroke-width: ${stroke.width}px`,\n        `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        'paint-order: stroke',\n    ].join(';');\n}\n\n/** Converts the tag styles into CSS. */\nconst templates = {\n    fontSize: `font-size: {{VALUE}}px`,\n    fontFamily: `font-family: {{VALUE}}`,\n    fontWeight: `font-weight: {{VALUE}}`,\n    fontStyle: `font-style: {{VALUE}}`,\n    fontVariant: `font-variant: {{VALUE}}`,\n    letterSpacing: `letter-spacing: {{VALUE}}px`,\n    align: `text-align: {{VALUE}}`,\n    padding: `padding: {{VALUE}}px`,\n    whiteSpace: `white-space: {{VALUE}}`,\n    lineHeight: `line-height: {{VALUE}}px`,\n    wordWrapWidth: `max-width: {{VALUE}}px`,\n};\n\n/** Converts the tag styles into CSS if modifications are required */\nconst transform = {\n    fill: (value: string) => `color: ${Color.shared.setValue(value).toHex()}`,\n    breakWords: (value: string) => `word-wrap: ${value ? 'break-all' : 'break-word'}`,\n    stroke: strokeToCSS,\n    dropShadow: dropShadowToCSS\n};\n\nfunction tagStyleToCSS(tagStyles: Record<string, HTMLTextStyleOptions>, out: string[])\n{\n    for (const i in tagStyles)\n    {\n        const tagStyle = tagStyles[i];\n        const cssTagStyle = [];\n\n        for (const j in tagStyle)\n        {\n            if (transform[j as keyof typeof transform])\n            {\n                // eslint-disable-next-line max-len\n                cssTagStyle.push(transform[j as keyof typeof transform](tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n            else if (templates[j as keyof typeof templates])\n            {\n                // eslint-disable-next-line max-len\n                cssTagStyle.push(templates[j as keyof typeof templates].replace('{{VALUE}}', tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n        }\n\n        out.push(`${i} { ${cssTagStyle.join(';')} }`);\n    }\n}\n","/* eslint-disable accessor-pairs */\nimport { warn } from '../../utils/logging/warn';\nimport { TextStyle } from '../text/TextStyle';\nimport { generateTextStyleKey } from '../text/utils/generateTextStyleKey';\nimport { textStyleToCSS } from './utils/textStyleToCSS';\n\nimport type { FillInput, StrokeInput } from '../graphics/shared/FillTypes';\nimport type { TextStyleOptions } from '../text/TextStyle';\n\n/**\n * Options for HTML text style, extends {@link TextStyle}.\n * @memberof text\n * @extends text.TextStyleOptions\n * @property {string[]} [cssOverrides] - CSS style(s) to add.\n * @property {Record<string, text.HTMLTextStyleOptions>} [tagStyles] - Tag styles.\n */\nexport interface HTMLTextStyleOptions extends Omit<TextStyleOptions, 'leading' | 'textBaseline' | 'trim' >\n{\n    cssOverrides?: string[];\n    tagStyles?: Record<string, HTMLTextStyleOptions>;\n}\n\n/**\n * A TextStyle object rendered by the HTMLTextSystem.\n * @memberof text\n */\nexport class HTMLTextStyle extends TextStyle\n{\n    private _cssOverrides: string[] = [];\n    private _cssStyle: string;\n    /**\n     * List of styles per tag.\n     * @example\n     * new HTMLText({\n     *   text:'<red>Red</red>,<blue>Blue</blue>,<green>Green</green>',\n     *   style:{\n     *       fontFamily: 'DM Sans',\n     *       fill: 'white',\n     *       fontSize:100,\n     *       tagStyles:{\n     *           red:{\n     *               fill:'red',\n     *           },\n     *           blue:{\n     *               fill:'blue',\n     *           },\n     *           green:{\n     *               fill:'green',\n     *           }\n     *       }\n     *   }\n     * );\n     */\n    public tagStyles: Record<string, HTMLTextStyleOptions>;\n\n    constructor(options: HTMLTextStyleOptions = {})\n    {\n        super(options);\n\n        this.cssOverrides ??= options.cssOverrides;\n        this.tagStyles = options.tagStyles ?? {};\n    }\n\n    /** List of style overrides that will be applied to the HTML text. */\n    set cssOverrides(value: string | string[])\n    {\n        this._cssOverrides = value instanceof Array ? value : [value];\n        this.update();\n    }\n\n    get cssOverrides(): string[]\n    {\n        return this._cssOverrides;\n    }\n\n    protected override _generateKey(): string\n    {\n        this._styleKey = generateTextStyleKey(this) + this._cssOverrides.join('-');\n\n        return this._styleKey;\n    }\n\n    public update()\n    {\n        this._cssStyle = null;\n        super.update();\n    }\n\n    /**\n     * Creates a new HTMLTextStyle object with the same values as this one.\n     * @returns New cloned HTMLTextStyle object\n     */\n    public clone(): HTMLTextStyle\n    {\n        return new HTMLTextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this.dropShadow ? { ...this.dropShadow } : null,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n            cssOverrides: this.cssOverrides,\n        });\n    }\n\n    get cssStyle(): string\n    {\n        if (!this._cssStyle)\n        {\n            this._cssStyle = textStyleToCSS(this);\n        }\n\n        return this._cssStyle;\n    }\n\n    /**\n     * Add a style override, this can be any CSS property\n     * it will override any built-in style. This is the\n     * property and the value as a string (e.g., `color: red`).\n     * This will override any other internal style.\n     * @param {string} value - CSS style(s) to add.\n     * @example\n     * style.addOverride('background-color: red');\n     */\n    public addOverride(...value: string[]): void\n    {\n        const toAdd = value.filter((v) => !this.cssOverrides.includes(v));\n\n        if (toAdd.length > 0)\n        {\n            this.cssOverrides.push(...toAdd);\n            this.update();\n        }\n    }\n\n    /**\n     * Remove any overrides that match the value.\n     * @param {string} value - CSS style to remove.\n     * @example\n     * style.removeOverride('background-color: red');\n     */\n    public removeOverride(...value: string[]): void\n    {\n        const toRemove = value.filter((v) => this.cssOverrides.includes(v));\n\n        if (toRemove.length > 0)\n        {\n            this.cssOverrides = this.cssOverrides.filter((v) => !toRemove.includes(v));\n            this.update();\n        }\n    }\n\n    override set fill(value: FillInput)\n    {\n        // if its not a string or a number, then its a texture!\n        if (typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color fill is not supported by HTMLText');\n            // #endif\n        }\n\n        super.fill = value;\n    }\n\n    override set stroke(value: StrokeInput)\n    {\n        // if its not a string or a number, then its a texture!\n        if (value && typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color stroke is not supported by HTMLText');\n            // #endif\n        }\n\n        super.stroke = value;\n    }\n}\n","import { loadFontAsBase64 } from './loadFontAsBase64';\n\nexport interface FontCSSStyleOptions\n{\n    fontFamily: string | string[]\n    fontWeight: string\n    fontStyle: string\n}\n\n/**\n * This will take a font url and a style and return a css string that can be injected into a style tag\n * This will contain inlined base64 font and the font family information\n * @param style - the style to generate the css for\n * @param url - The url to load the font from\n * @returns - The css string\n */\nexport async function loadFontCSS(style: FontCSSStyleOptions, url: string): Promise<string>\n{\n    const dataSrc = await loadFontAsBase64(url);\n\n    return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        src: url('${dataSrc}');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n","import { DOMAdapter } from '../../../environment/adapter';\n\n/**\n * Resolves a font url to a base64 string\n * @param url - The url to load the font from\n * @returns - The font as a base64 string\n */\nexport async function loadFontAsBase64(url: string): Promise<string>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const reader = new FileReader();\n\n    const dataSrc: string = await new Promise((resolve, reject) =>\n    {\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n\n    return dataSrc;\n}\n","import { Cache } from '../../../assets/cache/Cache';\nimport { loadFontCSS } from './loadFontCSS';\n\nimport type { FontCSSStyleOptions } from './loadFontCSS';\n\nexport const FontStylePromiseCache = new Map<string, Promise<string>>();\n\n/**\n * takes the font families and returns a css string that can be injected into a style tag\n * It will contain the font families and the font urls encoded as base64\n * @param fontFamilies - The font families to load\n * @param style - The FontCSSStyleOptions to load the font with (used for the first font family)\n * @param defaultOptions - The default options to load the font with (used for the rest of the font families)\n * @param defaultOptions.fontWeight - The default font weight\n * @param defaultOptions.fontStyle - The default font style\n * @returns - The css string\n */\nexport async function getFontCss(\n    fontFamilies: string[],\n    style: FontCSSStyleOptions,\n    defaultOptions: {fontWeight: string, fontStyle: string}\n)\n{\n    const fontPromises = fontFamilies\n        .filter((fontFamily) => Cache.has(`${fontFamily}-and-url`))\n        .map((fontFamily, i) =>\n        {\n            if (!FontStylePromiseCache.has(fontFamily))\n            {\n                const { url } = Cache.get(`${fontFamily}-and-url`);\n\n                if (i === 0)\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS(style, url));\n                }\n\n                else\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS({\n                        fontWeight: defaultOptions.fontWeight,\n                        fontStyle: defaultOptions.fontStyle,\n                        fontFamily,\n                    }, url));\n                }\n            }\n\n            return FontStylePromiseCache.get(fontFamily);\n        });\n\n    return (await Promise.all(fontPromises)).join('\\n');\n}\n","import { CanvasTextMetrics } from '../../text/canvas/CanvasTextMetrics';\nimport { HTMLTextRenderData } from '../HTMLTextRenderData';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { HTMLTextStyle } from '../HtmlTextStyle';\n\nlet tempHTMLTextRenderData: HTMLTextRenderData;\n\n/**\n * Measures the HTML text without actually generating an image.\n * This is used to calculate the size of the text.\n * @param text - The text to measure\n * @param style - The style to use\n * @param fontStyleCSS - The font css to use\n * @param htmlTextRenderData - The HTMLTextRenderData to write the SVG to\n * @returns - The size of the text\n */\nexport function measureHtmlText(\n    text: string,\n    style: HTMLTextStyle,\n    fontStyleCSS?: string,\n    htmlTextRenderData?: HTMLTextRenderData\n): Size\n{\n    htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n\n    const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n\n    domElement.setAttribute('style', 'transform-origin: top left; display: inline-block');\n\n    if (fontStyleCSS)\n    {\n        styleElement.textContent = fontStyleCSS;\n    }\n\n    // Measure the contents using the shadow DOM\n    document.body.appendChild(svgRoot);\n\n    const contentBounds = domElement.getBoundingClientRect();\n\n    svgRoot.remove();\n\n    const descenderPadding = CanvasTextMetrics.measureFont(style.fontStyle).descent;\n\n    return {\n        width: contentBounds.width,\n        height: contentBounds.height + descenderPadding,\n    };\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { isSafari } from '../../utils/browser/isSafari';\nimport { warn } from '../../utils/logging/warn';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource';\nimport { HTMLTextRenderData } from './HTMLTextRenderData';\nimport { HTMLTextStyle } from './HtmlTextStyle';\nimport { extractFontFamilies } from './utils/extractFontFamilies';\nimport { getFontCss } from './utils/getFontCss';\nimport { getSVGUrl } from './utils/getSVGUrl';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage';\nimport { loadSVGImage } from './utils/loadSVGImage';\nimport { measureHtmlText } from './utils/measureHtmlText';\n\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { HTMLTextOptions } from './HTMLText';\nimport type { FontCSSStyleOptions } from './utils/loadFontCSS';\n\ninterface HTMLTextTexture\n{\n    texture: Texture,\n    usageCount: number,\n    promise: Promise<Texture>,\n}\n\n/**\n * System plugin to the renderer to manage HTMLText\n * @memberof rendering\n */\nexport class HTMLTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    public static defaultFontOptions: FontCSSStyleOptions = {\n        fontFamily: 'Arial',\n        fontStyle: 'normal',\n        fontWeight: 'normal',\n    };\n\n    private _activeTextures: Record<string, HTMLTextTexture> = {};\n\n    /**\n     * WebGPU has a cors issue when uploading an image that is an SVGImage\n     * To get around this we need to create a canvas draw the image to it and upload that instead.\n     * Bit of a shame.. but no other work around just yet!\n     */\n    private readonly _createCanvas: boolean;\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._createCanvas = renderer.type === RendererType.WEBGPU;\n    }\n\n    public getTexture(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this._buildTexturePromise(\n            options.text as string,\n            options.resolution,\n            options.style as HTMLTextStyle\n        );\n    }\n\n    public getManagedTexture(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n        textKey: string\n    ): Promise<Texture>\n    {\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].promise;\n        }\n\n        const promise = this._buildTexturePromise(text, resolution, style)\n            .then((texture) =>\n            {\n                this._activeTextures[textKey].texture = texture;\n\n                return texture;\n            });\n\n        this._activeTextures[textKey] = {\n            texture: null,\n            promise,\n            usageCount: 1,\n        };\n\n        return promise;\n    }\n\n    private async _buildTexturePromise(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n    )\n    {\n        const htmlTextData = BigPool.get(HTMLTextRenderData);\n        const fontFamilies = extractFontFamilies(text, style);\n        const fontCSS = await getFontCss(\n            fontFamilies,\n            style,\n            HTMLTextStyle.defaultTextStyle as {fontWeight: string, fontStyle: string}\n        );\n        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const image = htmlTextData.image;\n\n        image.width = width | 0;\n        image.height = height | 0;\n\n        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n\n        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n\n        let resource: HTMLImageElement | HTMLCanvasElement = image;\n\n        if (this._createCanvas)\n        {\n            // silly webGPU workaround..\n            resource = getTemporaryCanvasFromImage(image, resolution);\n        }\n\n        const texture = getPo2TextureFromSource(resource, image.width, image.height, resolution);\n\n        if (this._createCanvas)\n        {\n            this._renderer.texture.initSource(texture.source);\n        }\n\n        BigPool.return(htmlTextData as PoolItem);\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        // TODO SHOULD NOT BE NEEDED\n        if (!activeTexture) return;\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            if (activeTexture.texture)\n            {\n                this._cleanUp(activeTexture);\n            }\n            else\n            {\n                // we did not resolve...\n                activeTexture.promise.then((texture) =>\n                {\n                    activeTexture.texture = texture;\n\n                    this._cleanUp(activeTexture);\n                }).catch(() =>\n                {\n                    // #if _DEBUG\n                    warn('HTMLTextSystem: Failed to clean texture');\n                    // #endif\n                });\n            }\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    private _cleanUp(activeTexture: HTMLTextTexture)\n    {\n        TexturePool.returnTexture(activeTexture.texture);\n        activeTexture.texture.source.resource = null;\n        activeTexture.texture.source.uploadMethodId = 'unknown';\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n","import type { HTMLTextStyle } from '../HtmlTextStyle';\n\n/**\n * Extracts font families from text. It will extract font families from the style, tagStyles and any font families\n * embedded in the text. It should also strip out duplicates as it goes.\n * @param  text - The text to extract font families from\n * @param style - The style to extract font families from\n * @returns {string[]} - The font families as an array of strings\n */\nexport function extractFontFamilies(text: string, style: HTMLTextStyle): string[]\n{\n    const fontFamily = style.fontFamily;\n    const fontFamilies: string[] = [];\n    const dedupe: Record<string, boolean> = {};\n\n    // first ensure fonts are loaded inline..\n    // find any font..\n    const regex = /font-family:([^;\"\\s]+)/g;\n\n    const matches = text.match(regex);\n\n    function addFontFamily(fontFamily: string)\n    {\n        if (!dedupe[fontFamily])\n        {\n            fontFamilies.push(fontFamily);\n\n            dedupe[fontFamily] = true;\n        }\n    }\n\n    if (Array.isArray(fontFamily))\n    {\n        for (let i = 0; i < fontFamily.length; i++)\n        {\n            addFontFamily(fontFamily[i]);\n        }\n    }\n    else\n    {\n        addFontFamily(fontFamily);\n    }\n\n    if (matches)\n    {\n        matches.forEach((match) =>\n        {\n            const fontFamily = match.split(':')[1].trim();\n\n            addFontFamily(fontFamily);\n        });\n    }\n\n    for (const i in style.tagStyles)\n    {\n        const fontFamily = style.tagStyles[i].fontFamily;\n\n        addFontFamily(fontFamily as string);\n    }\n\n    return fontFamilies;\n}\n","import type { HTMLTextRenderData } from '../HTMLTextRenderData';\nimport type { HTMLTextStyle } from '../HtmlTextStyle';\n\n/**\n * takes all the data and returns a svg url string can be loaded by an image element\n * @param text - The text to measure\n * @param style - The style to use\n * @param resolution - The resolution to use\n * @param fontCSS - The font css to use\n * @param htmlTextData - The HTMLTextRenderData to write the SVG to\n * @returns - The SVG as a url string\n */\nexport function getSVGUrl(\n    text: string,\n    style: HTMLTextStyle,\n    resolution: number,\n    fontCSS: string,\n    htmlTextData: HTMLTextRenderData\n)\n{\n    const { domElement, styleElement, svgRoot } = htmlTextData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n    domElement.setAttribute('style', `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n    styleElement.textContent = fontCSS;\n\n    const { width, height } = htmlTextData.image;\n\n    svgRoot.setAttribute('width', width.toString());\n    svgRoot.setAttribute('height', height.toString());\n\n    return new XMLSerializer().serializeToString(svgRoot);\n}\n","/**\n * This function loads an SVG image into an HTMLImageElement.\n * The image can then be uploaded as texture to the GPU.\n * iOS has a bug where embedded fonts are not available immediately after the image loads,\n * so we wait an arbitrary amount of time before resolving the promise.\n * @param image - The image to load the SVG into\n * @param url - The url to load the SVG from\n * @param delay - Whether to delay the load\n * @returns - A promise that resolves when the image has loaded\n */\nexport function loadSVGImage(image: HTMLImageElement, url: string, delay: boolean)\n{\n    return new Promise<void>(async (resolve) =>\n    {\n        // Safari has a known bug where embedded fonts are not available\n        // immediately after the image loads, to compensate we wait an\n        // arbitrary amount of time\n        // @see https://bugs.webkit.org/show_bug.cgi?id=219770\n        if (delay)\n        {\n            await new Promise<void>((resolve) => setTimeout(resolve, 100));\n        }\n\n        image.onload = () =>\n        {\n            resolve();\n        };\n\n        image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n        image.crossOrigin = 'anonymous';\n    });\n}\n","import { DOMAdapter } from '../../environment/adapter';\n\nexport function isSafari(): boolean\n{\n    const { userAgent } = DOMAdapter.get().getNavigator();\n\n    return (/^((?!chrome|android).)*safari/i).test(userAgent);\n}\n","import { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\n/**\n * This function converts an image to a canvas, and returns the canvas.\n * It is used to convert images to canvases to work around a CORS issue where WebGPU cannot\n * upload an SVGImage to a texture.\n *\n * It uses the CanvasPool to get an optimal canvas and context, and then draws the image onto it.\n * This canvas is immediately returned to the CanvasPool for reuse, so use the result straight away!\n * (eg upload it to the GPU!)\n * @param image - The image to convert to a canvas.\n * @param resolution - The resolution of the canvas.\n */\nexport function getTemporaryCanvasFromImage(image: HTMLImageElement, resolution: number): HTMLCanvasElement\n{\n    // Get an optimal canvas and context from the CanvasPool, based on the\n    // dimensions of the image and the desired resolution.\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n        image.width,\n        image.height,\n        resolution\n    );\n\n    // Clear the context of the canvas, and draw the image onto it.\n    const { context } = canvasAndContext;\n\n    context.clearRect(0, 0, image.width, image.height);\n    context.drawImage(image, 0, 0);\n\n    // Return the canvas and context to the CanvasPool.\n    CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n    // Return the canvas.\n    return canvasAndContext.canvas as HTMLCanvasElement;\n}\n\n","import { extensions } from '../../extensions/Extensions';\nimport { HTMLTextPipe } from './HTMLTextPipe';\nimport { HTMLTextSystem } from './HTMLTextSystem';\n\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { updateQuadBounds } from '../../../utils/data/updateQuadBounds';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../../sprite/BatchableSprite';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Text } from '../Text';\n\nexport class CanvasTextPipe implements RenderPipe<Text>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'text',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(text: Text): boolean\n    {\n        const gpuText = this._getGpuText(text);\n\n        const newKey = text._getKey();\n\n        if (gpuText.currentKey !== newKey)\n        {\n            const resolution = text.resolution ?? this._renderer.resolution;\n\n            const { width, height } = this._renderer.canvasText.getTextureSize(\n                text.text,\n                resolution,\n                text._style,\n            );\n\n            if (\n                // is only being used by this text:\n                this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1\n                // check the size of the text is the same po2\n                && width === gpuText.texture._source.width\n                && height === gpuText.texture._source.height\n            )\n            {\n                return false;\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(text: Text, _instructionSet: InstructionSet)\n    {\n        const gpuText = this._getGpuText(text);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n    }\n\n    public updateRenderable(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        batchableSprite.batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(text: Text)\n    {\n        this._destroyRenderableById(text.uid);\n    }\n\n    private _destroyRenderableById(textUid: number)\n    {\n        const gpuText = this._gpuText[textUid];\n\n        this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[textUid] = null;\n    }\n\n    private _updateText(text: Text)\n    {\n        const newKey = text._getKey();\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(text);\n        }\n\n        text._didTextUpdate = false;\n\n        const padding = text._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);\n    }\n\n    private _updateGpuText(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.texture)\n        {\n            this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n        }\n\n        gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getManagedTexture(text);\n\n        gpuText.currentKey = text._getKey();\n        batchableSprite.texture = gpuText.texture;\n    }\n\n    private _getGpuText(text: Text)\n    {\n        return this._gpuText[text.uid] || this.initGpuText(text);\n    }\n\n    public initGpuText(text: Text)\n    {\n        const gpuTextData: CanvasTextPipe['_gpuText'][number] = {\n            texture: null,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n        };\n\n        gpuTextData.batchableSprite.renderable = text;\n        gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        gpuTextData.batchableSprite.roundPixels = (this._renderer._roundPixels | text._roundPixels) as 0 | 1;\n\n        this._gpuText[text.uid] = gpuTextData;\n\n        this._updateText(text);\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        text.on('destroyed', () =>\n        {\n            this.destroyRenderable(text);\n        });\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n","import { Rectangle } from '../../maths/shapes/Rectangle';\n\nimport type { ICanvas } from '../../environment/canvas/ICanvas';\n\nfunction checkRow(data: Uint8ClampedArray, width: number, y: number)\n{\n    for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\nfunction checkColumn(data: Uint8ClampedArray, width: number, x: number, top: number, bottom: number)\n{\n    const stride = 4 * width;\n\n    for (let y = top, index = (top * stride) + (4 * x); y <= bottom; ++y, index += stride)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\n/**\n * Measuring the bounds of a canvas' visible (non-transparent) pixels.\n * @param canvas - The canvas to measure.\n * @param resolution - The resolution of the canvas.\n * @returns The bounding box of the canvas' visible pixels.\n * @since 7.1.0\n * @memberof utils\n */\nexport function getCanvasBoundingBox(canvas: ICanvas, resolution = 1): Rectangle\n{\n    // https://gist.github.com/timdown/021d9c8f2aabc7092df564996f5afbbf\n\n    const { width, height } = canvas;\n\n    const context = canvas.getContext('2d', {\n        willReadFrequently: true,\n    });\n\n    if (context === null)\n    {\n        throw new TypeError('Failed to get canvas 2D context');\n    }\n\n    const imageData = context.getImageData(0, 0, width, height);\n    const data = imageData.data;\n\n    let left = 0;\n    let top = 0;\n    let right = width - 1;\n    let bottom = height - 1;\n\n    while (top < height && checkRow(data, width, top)) ++top;\n    if (top === height) return Rectangle.EMPTY;\n    while (checkRow(data, width, bottom)) --bottom;\n    while (checkColumn(data, width, left, top, bottom)) ++left;\n    while (checkColumn(data, width, right, top, bottom)) --right;\n\n    ++right;\n    ++bottom;\n\n    return new Rectangle(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n}\n","import { Color } from '../../../color/Color';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { nextPow2 } from '../../../maths/misc/pow2';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox';\nimport { deprecation } from '../../../utils/logging/deprecation';\nimport { TextStyle } from '../TextStyle';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource';\nimport { CanvasTextMetrics } from './CanvasTextMetrics';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { TextOptions } from '../AbstractText';\nimport type { Text } from '../Text';\n\ninterface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * System plugin to the renderer to manage canvas text.\n * @memberof rendering\n */\nexport class CanvasTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasText',\n    } as const;\n\n    private _activeTextures: Record<string, {\n        canvasAndContext: CanvasAndContext,\n        texture: Texture,\n        usageCount: number,\n    }> = {};\n\n    private readonly _renderer: Renderer;\n\n    constructor(_renderer: Renderer)\n    {\n        this._renderer = _renderer;\n    }\n\n    public getTextureSize(text: string, resolution: number, style: TextStyle): { width: number, height: number }\n    {\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        let width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        let height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        width = Math.ceil((width) - 1e-6);\n        height = Math.ceil((height) - 1e-6);\n        width = nextPow2(width);\n        height = nextPow2(height);\n\n        return { width, height };\n    }\n\n    /**\n     * This is a function that will create a texture from a text string, style and resolution.\n     * Useful if you want to make a texture of your text and use if for various other pixi things!\n     * @param options - The options of the text that will be used to generate the texture.\n     * @param options.text - the text to render\n     * @param options.style - the style of the text\n     * @param options.resolution - the resolution of the texture\n     * @returns the newly created texture\n     */\n    /** @deprecated since 8.0.0 */\n    public getTexture(text: string, resolution: number, style: TextStyle, textKey: string): Texture;\n    public getTexture(options: TextOptions): Texture;\n    public getTexture(options: TextOptions | string, resolution?: number, style?: TextStyle, _textKey?: string): Texture\n    {\n        if (typeof options === 'string')\n        {\n            deprecation('8.0.0', 'CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments');\n\n            options = {\n                text: options,\n                style,\n                resolution,\n            };\n        }\n\n        if (!(options.style instanceof TextStyle))\n        {\n            options.style = new TextStyle(options.style);\n        }\n\n        const { texture, canvasAndContext } = this.createTextureAndCanvas(\n            options as {text: string, style: TextStyle, resolution?: number}\n        );\n\n        this._renderer.texture.initSource(texture._source);\n\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n        return texture;\n    }\n\n    public createTextureAndCanvas(options: {text: string, style: TextStyle, resolution?: number})\n    {\n        const { text, style } = options;\n\n        const resolution = options.resolution ?? this._renderer.resolution;\n\n        // create a canvas with the word hello on it\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n\n        // create a texture from the canvas\n        const { canvas } = canvasAndContext;\n\n        this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n\n        const texture = getPo2TextureFromSource(canvas, width, height, resolution);\n\n        if (style.trim)\n        {\n            const trimmed = getCanvasBoundingBox(canvas, resolution);\n\n            texture.frame.copyFrom(trimmed);\n\n            texture.updateUvs();\n        }\n\n        return { texture, canvasAndContext };\n    }\n\n    public getManagedTexture(text: Text)\n    {\n        const textKey = text._getKey();\n\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].texture;\n        }\n\n        const { texture, canvasAndContext } = this.createTextureAndCanvas(text);\n\n        this._activeTextures[textKey] = {\n            canvasAndContext,\n            texture,\n            usageCount: 1,\n        };\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);\n            TexturePool.returnTexture(activeTexture.texture);\n\n            const source = activeTexture.texture.source;\n\n            source.resource = null;\n            source.uploadMethodId = 'unknown';\n            source.alphaMode = 'no-premultiply-alpha';\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     *\n     * By default this is used internally to ensure the texture is correct before rendering,\n     * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n     * and then shared across multiple Sprites.\n     * @param text\n     * @param style\n     * @param resolution\n     * @param canvasAndContext\n     */\n    public renderTextToCanvas(text: string, style: TextStyle, resolution: number, canvasAndContext: CanvasAndContext): void\n    {\n        const { canvas, context } = canvasAndContext;\n\n        const font = fontStringFromTextStyle(style);\n\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);// , canvas);\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        const height = canvas.height;\n\n        context.resetTransform();\n\n        context.scale(resolution, resolution);\n\n        const padding = style.padding * 2;\n\n        context.clearRect(0, 0, measured.width + 4 + padding, measured.height + 4 + padding);\n\n        // set stroke styles..\n\n        if (style._stroke?.width)\n        {\n            const strokeStyle = style._stroke;\n\n            context.lineWidth = strokeStyle.width;\n\n            context.miterLimit = strokeStyle.miterLimit;\n            context.lineJoin = strokeStyle.join;\n            context.lineCap = strokeStyle.cap;\n        }\n\n        // return;\n        context.font = font;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (style.padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const shadowOptions = style.dropShadow;\n\n                const dropShadowColor = shadowOptions.color;\n                const dropShadowAlpha = shadowOptions.alpha;\n\n                context.shadowColor = Color.shared\n                    .setValue(dropShadowColor)\n                    .setAlpha(dropShadowAlpha)\n                    .toRgbaString();\n\n                const dropShadowBlur = shadowOptions.blur * resolution;\n                const dropShadowDistance = shadowOptions.distance * resolution;\n\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(shadowOptions.angle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                context.globalAlpha = style._fill?.alpha ?? 1;\n                context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context) : null;\n\n                if (style._stroke?.width)\n                {\n                    context.strokeStyle = getCanvasFillStyle(style._stroke, context);\n                }\n\n                context.shadowColor = 'black';\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            const strokeWidth = style._stroke?.width ?? 0;\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = strokeWidth / 2;\n                linePositionY = ((strokeWidth / 2) + (i * lineHeight)) + fontProperties.ascent + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style._stroke?.width)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style._fill !== undefined)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     * @param text - The text to draw\n     * @param style\n     * @param canvasAndContext\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     */\n    private _drawLetterSpacing(\n        text: string,\n        style: TextStyle,\n        canvasAndContext: CanvasAndContext,\n        x: number, y: number,\n        isStroke = false\n    ): void\n    {\n        const { context } = canvasAndContext;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        if (letterSpacing === 0 || useExperimentalLetterSpacing)\n        {\n            if (isStroke)\n            {\n                context.strokeText(text, x, y);\n            }\n            else\n            {\n                context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n        let previousWidth = context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem';\n\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from '../../container/bounds/Bounds';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst tempBounds = new Bounds();\n\n/**\n * Takes an image and creates a texture from it, using a power of 2 texture from the texture pool.\n * Remember to return the texture when you don't need it any more!\n * @param image - The image to create a texture from\n * @param width - the frame width of the texture\n * @param height - the frame height of the texture\n * @param resolution - The resolution of the texture\n * @returns - The texture\n */\nexport function getPo2TextureFromSource(\n    image: HTMLImageElement | HTMLCanvasElement | ICanvas,\n    width: number,\n    height: number,\n    resolution: number\n): Texture\n{\n    const bounds = tempBounds;\n\n    bounds.minX = 0;\n    bounds.minY = 0;\n\n    bounds.maxX = (image.width / resolution) | 0;\n    bounds.maxY = (image.height / resolution) | 0;\n\n    const texture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        resolution,\n        false\n    );\n\n    texture.source.uploadMethodId = 'image';\n    texture.source.resource = image;\n    texture.source.alphaMode = 'premultiply-alpha-on-upload';\n\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n\n    // We want to update the resource on the GPU,\n    // but we do not want to resize the texture.\n    // calling `texture.source.update` will fit the resource to the texture\n    // causing a resize of the texture on the GPU.\n    // which is not what we want!\n    texture.source.emit('update', texture.source);\n\n    texture.updateUvs();\n\n    return texture;\n}\n"],"names":["ResizePlugin","init","options","Object","defineProperty","this","set","dom","globalThis","removeEventListener","queueResize","_resizeTo","addEventListener","resize","get","_cancelResize","_resizeId","requestAnimationFrame","cancelAnimationFrame","width","height","window","innerWidth","innerHeight","clientWidth","clientHeight","renderer","render","resizeTo","destroy","extension","ExtensionType","Application","TickerPlugin","assign","autoStart","sharedTicker","ticker","_ticker","remove","add","UPDATE_PRIORITY","LOW","stop","start","Ticker","shared","oldTicker","extensions","FilterPipe","constructor","_renderer","push","filterEffect","container","instructionSet","renderPipes","batch","break","renderPipeId","canBundle","action","pop","_filterEffect","_container","execute","instruction","filter","type","WebGLPipes","WebGPUPipes","CanvasPipes","name","tempMatrix","Matrix","getFastGlobalBounds","target","bounds","clear","_getGlobalBoundsRecursive","isValid","renderGroup","applyMatrix","localTransform","parentRenderGroup","worldTransform","localDisplayStatus","measurable","manageEffects","effects","length","localBounds","boundsPool","boundsArea","addRect","viewBounds","addFrame","minX","minY","maxX","maxY","groupTransform","children","i","advanced","addBounds","copyTo","invert","relativeGroupTransform","return","quadGeometry","Geometry","attributes","aPosition","buffer","Float32Array","location","format","stride","offset","indexBuffer","Uint32Array","FilterSystem","_filterStackIndex","_filterStack","_filterGlobalUniforms","UniformGroup","uInputSize","value","uInputPixel","uInputClamp","uOutputFrame","uGlobalFrame","uOutputTexture","_globalFilterBindGroup","BindGroup","activeBackTexture","_this$_activeFilterDa","_activeFilterData","backTexture","filters","_getFilterData","filterData","skip","renderables","matrix","renderable","globalDisplayStatus","getGlobalRenderableBounds","filterArea","colorTextureSource","renderTarget","rootRenderTarget","colorTexture","source","resolution","_resolution","padding","antialias","blendRequired","enabled","_renderer$backBuffer$","_renderer$backBuffer","Math","min","compatibleRenderers","backBuffer","useBackBuffer","warn","viewPort","rootViewPort","scale","fitBounds","pad","ceil","isPositive","previousRenderSurface","renderSurface","inputTexture","TexturePool","getOptimalTexture","bind","globalUniforms","Texture","EMPTY","finishRenderPass","previousBounds","getRenderTarget","getBackTexture","setResource","style","apply","returnTexture","flip","flop","t","lastRenderSurface","backgroundResolution","x","y","floor","copyToTexture","applyFilter","input","output","Point","isFinalTarget","currentIndex","filterUniforms","uniforms","outputFrame","inputSize","inputPixel","inputClamp","globalFrame","outputTexture","lastIndex","filterData2","frame","pixelWidth","pixelHeight","rootTexture","isRoot","update","uniformBatch","batchUniforms","getUboResource","groups","encoder","draw","geometry","shader","state","_state","topology","RendererType","WEBGL","Bounds","calculateSpriteMatrix","outputMatrix","sprite","data","mappedMatrix","_source","prepend","texture","translate","anchor","WebGLSystem","WebGPUSystem","batchSamplersUniformGroupHash","getBatchSamplersUniformGroup","maxTextures","batchSamplersUniformGroup","sampleValues","Int32Array","uTextures","size","isStatic","GraphicsPipe","adaptor","State","for2d","_graphicsBatchesHash","create","_adaptor","validateRenderable","graphics","context","wasBatched","uid","gpuContext","graphicsContext","updateGpuContext","isBatchable","addRenderable","_didGraphicsUpdate","_rebuild","_addToBatcher","updateRenderable","batches","batcher","updateElement","destroyRenderable","_removeBatchForRenderable","isRenderable","getGpuContext","customShader","blendMode","groupBlendMode","localUniforms","resources","uTransformMatrix","uRound","_roundPixels","color32BitToUniform","groupColorAlpha","uColor","_initBatchesForRenderable","batched","batchPipe","_getBatchesForRenderable","addToBatch","roundPixels","map","batchClone","BigPool","BatchableGraphics","on","graphicsUid","forEach","GraphicsContextSystem","MeshPipe","localUniformsBindGroup","_meshDataHash","_gpuBatchableMeshHash","mesh","meshData","_getMeshData","isBatched","_geometry","indices","indexSize","positions","vertexSize","batchableMesh","_getBatchableMesh","checkAndUpdateTexture","gpuBatchableMesh","_texture","gpuMesh","_ref","getAdjustedBlendModeBlend","_initMeshData","_mesh$_geometry$indic","_mesh$_geometry$posit","_initBatchableMesh","BatchableMesh","_uvUpdateId","_textureMatrixUpdateId","reset","packIndex","index","indicesOffset","packAttributes","float32View","uint32View","textureId","wt","textureIdAndRound","a","b","c","d","tx","ty","uvBuffer","getBuffer","uvs","transformedUvs","textureMatrix","isSimple","_transformedUvs","_updateID","multiplyUvs","abgr","_MeshGeometry","arguments","undefined","deprecation","v8_0_0","defaultOptions","shrinkToFit","shrinkBuffersToFit","Buffer","label","usage","BufferUsage","VERTEX","COPY_DST","aUV","INDEX","batchMode","MeshGeometry","_PlaneGeometry","super","verticesX","verticesY","build","_this$verticesX","_this$verticesY","_this$width","_this$height","total","verts","sizeX","sizeY","totalSub","xpos","ypos","value2","value3","value4","buffers","PlaneGeometry","_NineSliceGeometry","_options$width","_options$height","_options$originalWidt","_options$originalHeig","_options$leftWidth","_options$rightWidth","_options$topHeight","_options$bottomHeight","_originalWidth","originalWidth","_originalHeight","originalHeight","_leftWidth","leftWidth","_rightWidth","rightWidth","_topHeight","topHeight","_bottomHeight","bottomHeight","updateUvs","updatePositions","w","scaleW","h","scaleH","_uvw","_uvh","NineSliceGeometry","NineSliceSpritePipe","_gpuSpriteHash","_instructionSet","gpuSprite","_getGpuSprite","_didSpriteUpdate","_updateBatchableSprite","batchableSprite","_initGPUSprite","tilingBit","vertex","header","main","fragment","tilingBitGl","gpuProgram","glProgram","TilingSpriteShader","Shader","_gpuProgram","_glProgram","compileHighShaderGpuProgram","bits","localUniformBit","roundPixelsBit","compileHighShaderGlProgram","localUniformBitGl","roundPixelsBitGl","tilingUniforms","uMapCoord","uClampFrame","uClampOffset","uTextureTransform","uSizeAnchor","uTexture","uSampler","updateUniforms","anchorX","anchorY","textureWidth","textureHeight","mapCoord","QuadGeometry","sharedQuad","TilingSpritePipe","default2d","_tilingSpriteDataHash","tilingSpriteData","_getTilingSpriteData","couldBatch","canBatch","_updateCanBatch","tilingSprite","_didTilingSpriteUpdate","_updateBatchableMesh","bindGroup","_tileTransform","_tilingSpriteData$sha","_initTilingSpriteData","slice","renderableData","addressMode","_applyAnchorToTexture","copyFrom","array","setUvs","setPositions","_nonPowOf2wrapping","supports","nonPowOf2wrapping","isPowerOfTwo","localUniformMSDFBit","end","localUniformMSDFBitGl","mSDFBit","mSDFBitGl","SdfShader","uDistance","getMaxTexturesPerBatch","colorBit","generateTextureBatchBit","colorBitGl","generateTextureBatchBitGl","batchSamplers","BitmapTextPipe","_gpuBitmapText","bitmapText","graphicsRenderable","_getGpuBitmapText","_didTextUpdate","_updateContext","syncWithProxy","_updateDistanceField","_destroyRenderableByUid","renderableUid","proxyGraphics","bitmapFont","BitmapFontManager","getFont","text","_style","distanceField","chars","Array","from","currentY","baseLineOffset","bitmapTextLayout","getBitmapTextLayout","_anchor","_x","_y","offsetY","tint","applyFillAsTint","_fill","color","lines","line","j","charPositions","char","charData","round","xOffset","yOffset","lineHeight","initGpuText","proxyRenderable","Graphics","fontFamily","dynamicFont","Cache","concat","dx","sqrt","dy","worldScale","abs","fontScale","baseRenderedFontSize","fontSize","distance","range","proxy","groupColor","groupAlpha","HTMLTextPipe","_gpuText","htmlText","gpuText","_getGpuText","newKey","_getKey","textureNeedsUploading","currentKey","_updateText","_destroyRenderableById","htmlTextUid","decreaseReferenceCount","_updateGpuText","catch","e","console","error","updateQuadBounds","_htmlText$resolution","generatingTexture","getManagedTexture","onViewUpdate","gpuTextData","BatchableSprite","nssvg","nsxhtml","HTMLTextRenderData","svgRoot","document","createElementNS","foreignObject","domElement","styleElement","image","Image","setAttribute","overflow","appendChild","textStyleToCSS","stroke","_stroke","fill","cssStyleString","Color","setValue","toHex","fontWeight","fontStyle","fontVariant","letterSpacing","align","whiteSpace","wordWrap","breakWords","wordWrapWidth","strokeToCSS","dropShadow","dropShadowToCSS","cssOverrides","join","cssStyles","tagStyles","out","tagStyle","cssTagStyle","transform","templates","replace","tagStyleToCSS","dropShadowStyle","setAlpha","alpha","toHexa","cos","angle","sin","position","blur","HTMLTextStyle","TextStyle","_this$cssOverrides","_options$tagStyles","_cssOverrides","_generateKey","_styleKey","generateTextStyleKey","_cssStyle","clone","cssStyle","addOverride","_len","_key","toAdd","v","includes","removeOverride","_len2","_key2","toRemove","loadFontCSS","url","dataSrc","response","DOMAdapter","fetch","blob","reader","FileReader","Promise","resolve","reject","onloadend","result","onerror","readAsDataURL","loadFontAsBase64","FontStylePromiseCache","Map","tempHTMLTextRenderData","HTMLTextSystem","_activeTextures","_createCanvas","WEBGPU","getTexture","_buildTexturePromise","textKey","_increaseReferenceCount","promise","then","usageCount","htmlTextData","fontFamilies","dedupe","matches","match","addFontFamily","fontFamily2","isArray","split","trim","extractFontFamilies","fontCSS","fontPromises","has","all","getFontCss","defaultTextStyle","measured","fontStyleCSS","htmlTextRenderData","innerHTML","textContent","body","contentBounds","getBoundingClientRect","descenderPadding","CanvasTextMetrics","measureFont","descent","measureHtmlText","max","svgURL","toString","XMLSerializer","serializeToString","getSVGUrl","delay","async","resolve2","setTimeout","onload","src","encodeURIComponent","crossOrigin","loadSVGImage","userAgent","getNavigator","test","isSafari","resource","canvasAndContext","CanvasPool","getOptimalCanvasAndContext","clearRect","drawImage","returnCanvasAndContext","canvas","getTemporaryCanvasFromImage","getPo2TextureFromSource","initSource","activeTexture","_cleanUp","uploadMethodId","getReferenceCount","CanvasSystem","defaultFontOptions","CanvasTextPipe","_text$resolution","canvasText","getTextureSize","textUid","checkRow","checkColumn","top","bottom","CanvasTextSystem","measureText","nextPow2","_textKey","createTextureAndCanvas","_options$resolution","renderTextToCanvas","trimmed","getContext","willReadFrequently","TypeError","getImageData","left","right","Rectangle","getCanvasBoundingBox","alphaMode","_style$_stroke","font","fontStringFromTextStyle","lineWidths","maxLineWidth","fontProperties","resetTransform","strokeStyle","lineWidth","miterLimit","lineJoin","lineCap","cap","linePositionX","linePositionY","passesCount","_style$_stroke$width","_style$_stroke3","isShadowPass","dsOffsetText","dsOffsetShadow","fillStyle","shadowOptions","dropShadowColor","dropShadowAlpha","shadowColor","toRgbaString","dropShadowBlur","dropShadowDistance","shadowBlur","shadowOffsetX","shadowOffsetY","_style$_fill$alpha","_style$_fill","_style$_stroke2","globalAlpha","getCanvasFillStyle","linePositionYShift","strokeWidth","i2","_style$_stroke4","ascent","_drawLetterSpacing","isStroke","useExperimentalLetterSpacing","experimentalLetterSpacingSupported","experimentalLetterSpacing","textLetterSpacing","strokeText","fillText","currentPosition","stringArray","graphemeSegmenter","previousWidth","currentWidth","currentChar","textStr","tempBounds","emit"],"sourceRoot":""}